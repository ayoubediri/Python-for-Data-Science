# Python-for-Data-Science
Pool in Python

أهلاً بك أيها الطالب العزيز في رحاب عالم برمجة الأنظمة المتعمقة، وتحديداً في الجزء الخاص بالتفاعل مع الطرفيات (Terminals) في بيئات يونكس وما شابهها. اليوم، سنغوص معاً في مجموعة من الدوال الأساسية التي تمكن برامجك من فهم البيئة التي تعمل فيها، والتحكم في كيفية تفاعلها مع المستخدم عبر الطرفية.

سيكون شرحنا بمثابة رحلة استكشافية، نبدأ فيها من المفاهيم الأولية ونبني عليها تدريجياً لنصل إلى فهم عميق لكل دالة، مع أمثلة عملية وتفاصيل دقيقة. تخيل أننا نمسك بيدك ونخطو خطوة بخطوة في هذا العالم المثير.

**مقدمة لا غنى عنها: ما هي الطرفية (Terminal)؟**

قبل أن نبدأ بدراسة الدوال، يجب أن نفهم ما هي "الطرفية" التي سنتعامل معها.

1.  **تاريخياً:** في بدايات الحوسبة، لم تكن هناك شاشات رسومية كما نعرفها اليوم. كان المستخدمون يتفاعلون مع الحاسوب المركزي (Mainframe) عبر أجهزة تسمى "طرفيات". كانت هذه الطرفيات تتكون عادةً من لوحة مفاتيح وشاشة (أو طابعة في الأجهزة الأقدم مثل Teletype، ومن هنا جاء الاختصار TTY). كانت هذه الأجهزة تتصل بالحاسوب المركزي عبر خطوط تسلسلية (Serial Lines).

2.  **في عالم يونكس:** استمر مفهوم الطرفية في أنظمة يونكس. في يونكس، "كل شيء ملف" (Everything is a file). الطرفيات أيضاً تُمثَّل كملفات خاصة في نظام الملفات، عادةً ما تجدها في المسار `/dev/`.
    *   **الطرفيات الفيزيائية (Physical Terminals):** مثل `/dev/ttyS0` (أو `/dev/cu.serial` في macOS) التي تمثل منافذ تسلسلية حقيقية يمكن توصيل أجهزة طرفية بها.
    *   **الطرفيات الافتراضية/الكونسول (Virtual Consoles/Consoles):** عندما تجلس أمام جهاز لينكس مباشرة (ليس عبر SSH)، وتضغط `Ctrl+Alt+F1` إلى `F6` (أو `F7`)، فأنت تنتقل بين عدة طرفيات افتراضية. هذه تُمثَّل بملفات مثل `/dev/tty1`, `/dev/tty2` وهكذا.
    *   **الطرفيات الزائفة (Pseudo-Terminals - PTYs):** هذه هي الأكثر شيوعاً اليوم. عندما تفتح نافذة طرفية في بيئة رسومية (مثل `gnome-terminal`, `konsole`, `xterm`, `iTerm2`) أو عندما تتصل بجهاز عن بعد باستخدام SSH، فأنت تستخدم طرفية زائفة. يتكون نظام الطرفية الزائفة من جزأين:
        *   **الجانب الرئيسي (PTY Master):** يُرمز له بـ `/dev/ptmx` (في الأنظمة الحديثة) أو مسارات مثل `/dev/ptyXY`. البرنامج الذي يُنشئ الطرفية (مثل `xterm` أو `sshd`) يفتح هذا الجانب.
        *   **الجانب التابع (PTY Slave):** يُرمز له بـ `/dev/pts/N` (حيث N هو رقم). هذا هو ما يراه البرنامج الذي يعمل "داخل" الطرفية (مثل `bash`, `vim`, أو برنامجك). كل ما يُكتب إلى الجانب الرئيسي يظهر كمدخل للجانب التابع، وكل ما يكتبه البرنامج إلى الجانب التابع يُقرأ من قبل الجانب الرئيسي.

3.  **لماذا نهتم؟** برامجك قد تحتاج إلى:
    *   معرفة ما إذا كانت تعمل بشكل تفاعلي مع مستخدم (أي متصلة بطرفية) أم أن مدخلاتها/مخرجاتها موجهة من/إلى ملف أو أنبوب (pipe).
    *   الحصول على اسم الطرفية المتصلة بها.
    *   تغيير سلوك الطرفية (مثل إيقاف صدى الأحرف عند كتابة كلمة مرور، أو قراءة حرف واحد بمجرد الضغط عليه دون انتظار Enter).
    *   تحريك المؤشر، تغيير الألوان، مسح الشاشة بطريقة مستقلة عن نوع الطرفية الفعلية.

**مفهوم واصف الملف (File Descriptor)**

قبل أن نتقدم، دعنا نراجع بسرعة مفهوم "واصف الملف". في يونكس، عندما يفتح برنامج ما ملفاً (أو جهازاً، أو مقبساً شبكياً، إلخ)، يقوم نظام التشغيل بإرجاع رقم صحيح صغير غير سالب يسمى "واصف الملف". هذا الرقم هو بمثابة "مقبض" أو "معرّف" يستخدمه البرنامج للإشارة إلى هذا الملف المفتوح في جميع العمليات اللاحقة (قراءة، كتابة، إغلاق).

هناك ثلاثة واصفات ملفات قياسية تُفتح تلقائياً لكل عملية عند بدئها:
*   **0 (STDIN_FILENO):** الإدخال القياسي (Standard Input). عادةً ما يكون لوحة المفاتيح.
*   **1 (STDOUT_FILENO):** الإخراج القياسي (Standard Output). عادةً ما يكون شاشة الطرفية.
*   **2 (STDERR_FILENO):** إخراج الخطأ القياسي (Standard Error Output). عادةً ما يكون شاشة الطرفية أيضاً.

الآن، بعد هذه المقدمة الضرورية، دعنا نبدأ رحلتنا مع الدوال.

---

**الكتاب الشامل: دوال التفاعل مع الطرفيات في C**

---

**الفصل الأول: تحديد طبيعة واصف الملف والطرفية**

في هذا الفصل، سنتناول الدوال التي تساعدنا على فهم ما إذا كان برنامجنا يتفاعل مع طرفية حقيقية أم لا، وما هو اسم هذه الطرفية.

---

**1. الدالة `isatty()`**

*   **الغرض (Purpose):**
    تُستخدم الدالة `isatty()` لاختبار ما إذا كان واصف ملف معين (file descriptor) يشير إلى جهاز طرفية (terminal device). ببساطة، تسألها: "هل هذا الواصف متصل بطرفية؟".

*   **التضمين (Header File):**
    ```c
    #include <unistd.h>
    ```

*   **التصريح (Synopsis):**
    ```c
    int isatty(int fd);
    ```

*   **المعاملات (Parameters):**
    *   `int fd`: واصف الملف (file descriptor) الذي تريد اختباره. هذا هو الرقم الصحيح الذي حصلت عليه عند فتح ملف أو جهاز، أو أحد الواصفات القياسية (0، 1، أو 2).

*   **القيمة المُرجعة (Return Value):**
    *   إذا كان `fd` يشير إلى طرفية، تُرجع الدالة `1` (يعني "صحيح" أو true).
    *   إذا لم يكن `fd` يشير إلى طرفية، تُرجع الدالة `0` (يعني "خطأ" أو false)، وتُعيّن قيمة للمتغير العام `errno` للإشارة إلى سبب الخطأ. أكثر الأخطاء شيوعاً هنا هو `ENOTTY` (Not a typewriter)، والذي يعني أن الواصف لا يشير إلى جهاز طرفية. قد تحدث أخطاء أخرى مثل `EBADF` إذا كان `fd` واصف ملف غير صالح.

*   **الشرح التفصيلي (Detailed Explanation):**
    تعمل `isatty()` عادةً عن طريق محاولة تنفيذ عملية `ioctl()` (سنتحدث عنها لاحقاً بالتفصيل) خاصة بالطرفيات على واصف الملف المُعطى. إذا نجحت هذه العملية (مثل `TCGETS` أو `TIOCGETA` لجلب إعدادات الطرفية)، فهذا يعني أن الواصف يشير إلى طرفية. إذا فشلت العملية مع خطأ `ENOTTY`، فهذا يعني أنه ليس طرفية.

    هذه الدالة مفيدة جداً عندما تريد أن يتصرف برنامجك بشكل مختلف اعتماداً على ما إذا كان يتفاعل مع مستخدم بشكل مباشر أم لا. على سبيل المثال:
    *   **المطالبات (Prompts):** قد يرغب برنامجك في طباعة مطالبة (مثل `Enter command: `) فقط إذا كان الإخراج القياسي (stdout) متصلاً بطرفية. إذا كان الإخراج موجهاً إلى ملف، فلا معنى لطباعة المطالبة.
    *   **كلمات المرور:** عند قراءة كلمة مرور، قد ترغب في تعطيل صدى الأحرف (echoing) على الشاشة. هذا ممكن فقط إذا كان الإدخال القياسي (stdin) متصلاً بطرفية.
    *   **الألوان والتنسيق:** قد يستخدم برنامجك أكواد ANSI للتحكم في الألوان أو تنسيق النص إذا كان الإخراج يذهب إلى طرفية تدعم ذلك. إذا كان الإخراج يذهب إلى ملف، فهذه الأكواد ستظهر كأحرف غريبة.

*   **أمثلة عملية (Use Cases/Examples):**

    ```c
    #include <stdio.h>
    #include <unistd.h> // For isatty(), STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO
    #include <fcntl.h>  // For open(), O_RDONLY
    #include <errno.h>  // For errno

    int main() {
        // التحقق من الإدخال القياسي (stdin)
        if (isatty(STDIN_FILENO)) {
            printf("Standard input (stdin) is a TTY.\n");
        } else {
            printf("Standard input (stdin) is NOT a TTY. errno: %d (%s)\n", errno, strerror(errno));
            // قد يكون stdin مُعاد توجيهه من ملف أو أنبوب
        }

        // التحقق من الإخراج القياسي (stdout)
        if (isatty(STDOUT_FILENO)) {
            printf("Standard output (stdout) is a TTY.\n");
        } else {
            // لا يمكننا استخدام printf هنا بشكل موثوق إذا كان stdout ليس TTY
            // لأنه سيحاول الكتابة إلى مكان غير طرفي.
            // يمكننا الكتابة إلى stderr بدلاً من ذلك، إذا كان TTY.
            if (isatty(STDERR_FILENO)) {
                fprintf(stderr, "Standard output (stdout) is NOT a TTY. errno: %d (%s)\n", errno, strerror(errno));
            }
            // قد يكون stdout مُعاد توجيهه إلى ملف أو أنبوب
        }

        // التحقق من إخراج الخطأ القياسي (stderr)
        if (isatty(STDERR_FILENO)) {
            fprintf(stderr, "Standard error (stderr) is a TTY.\n");
        } else {
            // إذا كان حتى stderr ليس TTY، فالوضع صعب لطباعة أي شيء
            // يمكن محاولة الكتابة إلى /dev/tty إذا كانت متاحة كحل أخير
            fprintf(stderr, "Standard error (stderr) is NOT a TTY. errno: %d (%s)\n", errno, strerror(errno));
        }

        // مثال مع ملف عادي
        int fd_file = open("testfile.txt", O_CREAT | O_RDWR, 0666);
        if (fd_file == -1) {
            perror("Failed to open testfile.txt");
            return 1;
        }
        printf("Checking testfile.txt (fd: %d):\n", fd_file);
        if (isatty(fd_file)) {
            printf("  testfile.txt is a TTY (This should not happen for a regular file!).\n");
        } else {
            printf("  testfile.txt is NOT a TTY. errno: %d (%s)\n", errno, strerror(errno));
            if (errno == ENOTTY) {
                printf("    Error is ENOTTY, as expected for a regular file.\n");
            }
        }
        close(fd_file);
        remove("testfile.txt"); // Clean up

        return 0;
    }
    ```

    **لتجربة المثال:**
    1.  **احفظ الكود** باسم `check_tty.c`.
    2.  **ترجمه (Compile):** `gcc check_tty.c -o check_tty`
    3.  **شغله مباشرة:** `./check_tty`
        سترى أن `stdin`, `stdout`, و `stderr` هي TTYs.
    4.  **شغله مع إعادة توجيه الإدخال:** `echo "hello" | ./check_tty`
        سترى أن `stdin` لم يعد TTY.
    5.  **شغله مع إعادة توجيه الإخراج:** `./check_tty > output.txt`
        سترى أن `stdout` لم يعد TTY (الرسالة ستُطبع على `stderr` أو في `output.txt` بدون التحقق).
    6.  **شغله مع إعادة توجيه كليهما:** `echo "hello" | ./check_tty > output.txt`

*   **اعتبارات هامة (Important Considerations):**
    *   عندما يُرجع `isatty()` القيمة 0، يجب دائماً التحقق من `errno` لمعرفة سبب الفشل. الخطأ `ENOTTY` هو الحالة "الطبيعية" لملف ليس طرفية. أي خطأ آخر قد يشير إلى مشكلة أعمق (مثل واصف ملف غير صالح `EBADF`).
    *   تذكر أن `isatty()` تعمل على واصفات الملفات، وليس على مسارات الملفات (أسماء الملفات). يجب أولاً فتح الملف/الجهاز للحصول على واصف ملف.
    *   في الأنظمة الحديثة، عادةً ما تكون الطرفيات التي تستخدمها في النوافذ الرسومية أو عبر SSH هي طرفيات زائفة (pseudo-terminals)، ولكن `isatty()` ستظل تُرجع 1 لها لأنها تتصرف كطرفيات.

---

**2. الدالة `ttyname()`**

*   **الغرض (Purpose):**
    إذا كان واصف ملف معين يشير إلى طرفية، فإن الدالة `ttyname()` تُرجع مؤشراً (pointer) إلى سلسلة نصية (string) تحتوي على اسم المسار (pathname) لملف الطرفية هذا في نظام الملفات (مثلاً، `/dev/tty1` أو `/dev/pts/5`).

*   **التضمين (Header File):**
    ```c
    #include <unistd.h> // POSIX standard
    // #include <stdio.h> // تاريخياً، بعض الأنظمة القديمة جداً قد تضعه هنا، ولكن unistd.h هو الصحيح
    ```

*   **التصريح (Synopsis):**
    ```c
    char *ttyname(int fd);
    ```

*   **المعاملات (Parameters):**
    *   `int fd`: واصف الملف الذي تريد الحصول على اسم الطرفية المرتبط به.

*   **القيمة المُرجعة (Return Value):**
    *   إذا كان `fd` يشير إلى طرفية وكان الاسم متاحاً، تُرجع `ttyname()` مؤشراً إلى سلسلة نصية (null-terminated string) تحتوي على اسم ملف الطرفية. **هذه السلسلة النصية موجودة في منطقة ذاكرة ثابتة (static storage) وقد يتم الكتابة فوقها (overwritten) بواسطة استدعاءات لاحقة لـ `ttyname()` أو دوال أخرى معينة (مثل `readdir`, `getpwent` في بعض الأنظمة القديمة). لذا، إذا كنت تريد الاحتفاظ بالاسم، يجب نسخه إلى مخزن مؤقت (buffer) خاص بك.**
    *   إذا لم يكن `fd` يشير إلى طرفية، أو إذا حدث خطأ آخر، تُرجع الدالة `NULL`، وتُعيّن قيمة للمتغير `errno` للإشارة إلى الخطأ. الأخطاء الشائعة:
        *   `EBADF`: واصف الملف `fd` غير صالح.
        *   `ENOTTY`: واصف الملف `fd` لا يشير إلى جهاز طرفية.
        *   `ERANGE`: (في بعض التطبيقات) حجم المخزن المؤقت الداخلي غير كافٍ لاسم الطرفية. (هذا أقل شيوعًا للدالة `ttyname` القياسية التي تدير مخزنها المؤقت بنفسها، ولكنه قد يكون ذا صلة بدالة `ttyname_r` الأكثر أمانًا).

*   **الشرح التفصيلي (Detailed Explanation):**
    كيف تعرف `ttyname()` اسم الطرفية؟
    يعتمد التنفيذ الداخلي على نظام التشغيل، ولكن الفكرة العامة هي كما يلي:
    1.  **التحقق الأولي:** تتأكد أولاً أن `fd` هو بالفعل طرفية (ربما باستخدام آلية مشابهة لـ `isatty()`).
    2.  **الحصول على معلومات الجهاز:** لكل ملف مفتوح، يحتفظ نظام التشغيل بمعلومات حول الجهاز الذي ينتمي إليه هذا الملف (رقم الجهاز الرئيسي major device number ورقم الجهاز الثانوي minor device number) ونوع الملف (عادي، مجلد، جهاز محرفي، جهاز كتلي، إلخ). إذا كان `fd` طرفية، فإنه سيكون ملف جهاز محرفي (character device file).
    3.  **البحث في `/dev`:** تقوم الدالة بعد ذلك بالبحث في الدليل `/dev` (وفي بعض الأحيان أدلة فرعية مثل `/dev/pts`) عن ملف جهاز محرفي له نفس رقم الجهاز الرئيسي والثانوي ونوع الملف المطابق للمعلومات التي تم الحصول عليها من `fd`.
    4.  **إرجاع المسار:** عند العثور على تطابق، تُرجع مسار هذا الملف.

    **ملاحظة حول الذاكرة الثابتة:** كون السلسلة المُرجعة في ذاكرة ثابتة يعني أنك إذا استدعيت `ttyname()` مرتين متتاليتين لـ `fd` مختلفين (وكلاهما طرفيات)، فإن المؤشر المُرجع من الاستدعاء الأول قد يصبح غير صالح أو يشير إلى اسم الطرفية الثانية بعد الاستدعاء الثاني.

    ```c
    char *name1 = ttyname(STDIN_FILENO);
    char *name2 = ttyname(STDOUT_FILENO);
    // الآن name1 قد يشير إلى نفس البيانات التي يشير إليها name2 إذا كان كلاهما نفس الطرفية،
    // أو قد يكون name1 قد تم الكتابة فوقه إذا كانت هناك آلية ذاكرة ثابتة واحدة مشتركة.
    // لذلك، إذا احتجت إلى name1 لاحقاً، انسخه:
    // char my_tty_name[256];
    // if (name1) strncpy(my_tty_name, name1, sizeof(my_tty_name)-1);
    // my_tty_name[sizeof(my_tty_name)-1] = '\0';
    ```

    لهذا السبب، توجد نسخة أكثر أماناً من هذه الدالة تسمى `ttyname_r()` (re-entrant version).

*   **الدالة البديلة الآمنة: `ttyname_r()`**
    *   **التضمين:** `unistd.h`
    *   **التصريح:** `int ttyname_r(int fd, char *buf, size_t buflen);`
    *   **المعاملات:**
        *   `int fd`: واصف الملف.
        *   `char *buf`: مؤشر إلى مخزن مؤقت (buffer) توفره أنت، حيث سيتم تخزين اسم الطرفية.
        *   `size_t buflen`: حجم المخزن المؤقت `buf` بالبايت.
    *   **القيمة المُرجعة:**
        *   `0` عند النجاح.
        *   رقم خطأ موجب (مثل `EBADF`, `ENOTTY`, `ERANGE` إذا كان `buflen` صغيراً جداً) عند الفشل. لاحظ أنها تُرجع رقم الخطأ مباشرةً ولا تُعيّن `errno` (هذا شائع في الدوال الآمنة من نوع `_r`).
    *   **لماذا هي أفضل؟** لأنك توفر المخزن المؤقت بنفسك، فلا يوجد خطر من الكتابة فوق بيانات في ذاكرة ثابتة، وهي آمنة للاستخدام في السياقات متعددة الخيوط (thread-safe).

*   **أمثلة عملية (Use Cases/Examples):**

    ```c
    #include <stdio.h>
    #include <unistd.h>   // For ttyname(), STDIN_FILENO
    #include <string.h>   // For strdup() or strcpy()
    #include <stdlib.h>   // For free() if using strdup()
    #include <errno.h>    // For errno

    // For ttyname_r
    #define TTY_NAME_BUF_SIZE 256

    int main() {
        char *tty_s;
        char my_tty_name_buffer[TTY_NAME_BUF_SIZE]; // For demonstration with ttyname_r

        // --- استخدام ttyname() ---
        printf("--- Using ttyname() ---\n");
        if (isatty(STDIN_FILENO)) {
            tty_s = ttyname(STDIN_FILENO);
            if (tty_s != NULL) {
                printf("The TTY for stdin is: %s\n", tty_s);

                // إذا أردت الاحتفاظ بالاسم، انسخه
                char *saved_tty_name = strdup(tty_s); // strdup يخصص ذاكرة وينسخ
                if (saved_tty_name) {
                    printf("Copied TTY name for stdin: %s\n", saved_tty_name);
                    // لاحقاً، يمكنك استخدام saved_tty_name
                    free(saved_tty_name); // لا تنس تحرير الذاكرة
                } else {
                    perror("strdup failed");
                }
            } else {
                fprintf(stderr, "ttyname(STDIN_FILENO) failed. errno: %d (%s)\n", errno, strerror(errno));
            }
        } else {
            printf("stdin is not a TTY, so ttyname() is not applicable.\n");
        }

        // --- استخدام ttyname_r() ---
        printf("\n--- Using ttyname_r() ---\n");
        if (isatty(STDOUT_FILENO)) { // لنجرب مع stdout هذه المرة
            int result = ttyname_r(STDOUT_FILENO, my_tty_name_buffer, TTY_NAME_BUF_SIZE);
            if (result == 0) {
                printf("The TTY for stdout (using ttyname_r) is: %s\n", my_tty_name_buffer);
            } else {
                // result هو رقم الخطأ مباشرةً
                fprintf(stderr, "ttyname_r(STDOUT_FILENO) failed with error code: %d (%s)\n", result, strerror(result));
                if (result == ERANGE) {
                    fprintf(stderr, "Buffer too small. Required size might be larger than %d.\n", TTY_NAME_BUF_SIZE);
                }
            }
        } else {
            printf("stdout is not a TTY, so ttyname_r() is not applicable.\n");
        }

        // مثال على واصف ملف غير طرفي
        printf("\n--- Testing with non-TTY fd ---\n");
        int fd_file = open("temp.txt", O_CREAT | O_RDWR, 0666);
        if (fd_file == -1) {
            perror("Failed to open temp.txt");
            return 1;
        }
        tty_s = ttyname(fd_file);
        if (tty_s == NULL) {
            printf("ttyname() for fd_file correctly returned NULL.\n");
            if (errno == ENOTTY) {
                printf("  errno is ENOTTY, as expected, because fd_file is not a TTY.\n");
            } else {
                fprintf(stderr, "  errno: %d (%s)\n", errno, strerror(errno));
            }
        } else {
            // هذا لا يجب أن يحدث
            printf("  ttyname() for fd_file returned: %s (Unexpected!)\n", tty_s);
        }
        close(fd_file);
        remove("temp.txt");

        return 0;
    }
    ```

    **لتجربة المثال:**
    1.  **احفظ الكود** باسم `get_tty_name.c`.
    2.  **ترجمه:** `gcc get_tty_name.c -o get_tty_name`
    3.  **شغله:** `./get_tty_name`
        سترى أسماء الطرفيات (عادةً شيء مثل `/dev/pts/X`).

*   **اعتبارات هامة (Important Considerations):**
    *   **الأمان:** يُفضل دائماً استخدام `ttyname_r()` في الشيفرات الجديدة، خاصة في البيئات متعددة الخيوط أو حيثما تكون هناك حاجة ماسة للاعتمادية، لتجنب مشاكل الذاكرة الثابتة.
    *   **قابلية النقل (Portability):** كل من `ttyname()` و `ttyname_r()` معياريتان (POSIX).
    *   **الاستخدام:** تُستخدم هذه الدالة غالباً لأغراض التسجيل (logging)، أو عندما يحتاج برنامج إلى معرفة الطرفية التي يعمل عليها لأسباب خاصة (مثلاً، بعض برامج إدارة الجلسات).
    *   **القيود الأمنية:** في بعض الأنظمة أو التكوينات الأمنية المشددة، قد لا يتمكن البرنامج من الوصول إلى معلومات كافية لتحديد اسم الطرفية، حتى لو كان `isatty()` يُرجع true.

---

**3. الدالة `ttyslot()`**

*   **الغرض (Purpose):**
    تُستخدم الدالة `ttyslot()` للعثور على "فتحة" (slot) أو مدخل (entry) الطرفية الحالية للعملية في ملف محاسبة المستخدمين (user accounting file). تاريخياً، كان هذا الملف هو `/etc/utmp` (أو ما يعادله)، الذي يتتبع المستخدمين المسجلين دخولهم إلى النظام والطرفيات التي يستخدمونها. تُرجع هذه الدالة فهرس (index) مدخل الطرفية في هذا الملف.

    **ملاحظة هامة:** تُعتبر هذه الدالة **قديمة ومهملة (obsolete/deprecated)** في العديد من الأنظمة الحديثة. الاعتماد على ملفات مثل `utmp` مباشرة له مشاكله، والأنظمة الحديثة قد تستخدم آليات مختلفة لتتبع الجلسات. استخدامها قد لا يكون قابلاً للنقل أو موثوقاً به دائماً.

*   **التضمين (Header File):**
    ```c
    #include <unistd.h> // POSIX
    // #include <stdlib.h> // بعض الأنظمة القديمة جداً قد تضعها هنا
    ```

*   **التصريح (Synopsis):**
    ```c
    int ttyslot(void);
    ```

*   **المعاملات (Parameters):**
    لا تأخذ هذه الدالة أي معاملات. هي تعمل ضمنياً على الطرفية المتحكمة (controlling terminal) للعملية الحالية.

*   **القيمة المُرجعة (Return Value):**
    *   إذا نجحت في العثور على مدخل للطرفية المتحكمة للعملية الحالية في ملف محاسبة المستخدمين، فإنها تُرجع رقم الفتحة (عادةً فهرس غير سالب يبدأ من 1، ولكن هذا يعتمد على التنفيذ).
    *   إذا لم تكن العملية مرتبطة بطرفية، أو إذا لم تتمكن من العثور على المدخل، أو إذا حدث خطأ، فإنها تُرجع `0` أو قيمة سالبة (مثل `-1`). لا يتم تعيين `errno` بشكل موثوق بواسطة هذه الدالة في جميع الأنظمة عند الفشل.

*   **الشرح التفصيلي (Detailed Explanation):**
    الفكرة وراء `ttyslot()` تعود إلى الأيام التي كان فيها عدد الطرفيات محدوداً، وكان من المهم تتبع أي مستخدم يستخدم أي طرفية.
    1.  أولاً، تحاول الدالة تحديد اسم الطرفية المتحكمة للعملية الحالية. قد تفعل ذلك داخلياً باستخدام شيء يشبه `ttyname(0)` أو `ttyname(1)` أو `ttyname(2)` (أي بالبحث عن أول واصف ملف قياسي متصل بطرفية).
    2.  بمجرد الحصول على اسم الطرفية (مثلاً، `/dev/tty1` أو `/dev/pts/5`), تقوم الدالة بمسح ملف محاسبة المستخدمين (مثل `/etc/utmp` أو `/var/run/utmp` أو `/var/log/wtmp` في بعض السياقات).
    3.  هذا الملف يحتوي على سجلات، كل سجل يمثل جلسة مستخدم على طرفية معينة. تبحث `ttyslot()` عن سجل يتطابق فيه حقل اسم الطرفية مع اسم الطرفية المتحكمة التي وجدتها.
    4.  إذا تم العثور على تطابق، فإن الدالة تُرجع موقع (عادةً فهرس) هذا السجل داخل الملف.

    **لماذا هي مهملة؟**
    *   **الأمان والخصوصية:** القراءة المباشرة لملفات مثل `utmp` قد تكون لها آثار أمنية أو خصوصية.
    *   **البدائل:** الأنظمة الحديثة لديها آليات أفضل لإدارة الجلسات (مثل `logind` في systemd).
    *   **الاعتمادية:** تنسيق وموقع ملف `utmp` يمكن أن يختلف بين الأنظمة، وحتى محتوياته قد لا تكون دائماً متزامنة بشكل مثالي.
    *   **الطرفيات الزائفة:** مع انتشار الطرفيات الزائفة (PTYs)، مفهوم "الفتحة" الثابتة أصبح أقل وضوحاً.

*   **أمثلة عملية (Use Cases/Examples):**
    بسبب طبيعتها المهملة وصعوبة ضمان عملها بشكل متسق عبر الأنظمة الحديثة، لن أقدم مثالاً معقداً. لكن يمكن تصور استخدامها كالتالي (مع التحذير بأنها قد لا تعمل كما هو متوقع):

    ```c
    #include <stdio.h>
    #include <unistd.h> // For ttyslot()

    int main() {
        int slot;

        slot = ttyslot();

        if (slot > 0) {
            printf("This terminal's slot in the user accounting file is (approximately): %d\n", slot);
            printf("Note: This function is often deprecated and results may vary.\n");
        } else if (slot == 0) {
            printf("Could not find a slot for this terminal (or process not attached to a TTY).\n");
            printf("Note: ttyslot() returning 0 can mean not found or an error.\n");
        } else { // slot < 0
            printf("ttyslot() returned an error indication: %d\n", slot);
        }

        // كيف يمكن أن تستخدم هذه المعلومة (نظرياً)؟
        // يمكنك محاولة فتح ملف /etc/utmp (أو ما يعادله)
        // والقفز إلى السجل رقم 'slot' لقراءة معلومات المستخدم.
        // لكن هذا معقد ويتجاوز نطاق الدالة نفسها، وهو غير موصى به.
        // FILE *utmp_file = fopen("/etc/utmp", "r");
        // if (utmp_file) {
        //     // ... seek to slot, read struct utmp ...
        //     fclose(utmp_file);
        // }

        return 0;
    }
    ```

    **لتجربة المثال (مع توقع نتائج غير مضمونة):**
    1.  **احفظ الكود** باسم `check_slot.c`.
    2.  **ترجمه:** `gcc check_slot.c -o check_slot`
    3.  **شغله:** `./check_slot`
        قد تحصل على رقم، أو 0، أو قد لا يعمل البرنامج أصلاً إذا كانت الدالة غير موجودة أو لا تعمل بشكل صحيح على نظامك. على نظام Linux حديث، قد تُرجع 0.

*   **اعتبارات هامة (Important Considerations):**
    *   **لا تعتمد عليها:** تجنب استخدام `ttyslot()` في الشيفرات الجديدة. إذا كنت بحاجة إلى معلومات حول جلسة المستخدم، ابحث عن واجهات برمجة تطبيقات (APIs) أحدث وأكثر موثوقية يوفرها نظام التشغيل (مثل واجهات PAM، أو systemd-logind API).
    *   **البديل التاريخي:** كانت تُستخدم أحياناً مع دوال مثل `getutent()`، `getutid()`، `getutline()` لقراءة ومعالجة ملف `utmp`.
    *   إذا كنت مضطراً للتعامل مع أنظمة قديمة جداً، قد تكون هذه الدالة ذات صلة، ولكن حتى في هذه الحالة، تعامل معها بحذر.

---
**ملخص الفصل الأول:**
لقد تعلمنا الآن كيف:
1.  نتحقق مما إذا كان واصف ملف يشير إلى طرفية باستخدام `isatty()`.
2.  نحصل على اسم ملف الطرفية باستخدام `ttyname()` (والنسخة الآمنة `ttyname_r()`).
3.  (نظرياً) نجد "فتحة" الطرفية في ملفات المحاسبة القديمة باستخدام `ttyslot()` (مع التحذير بأنها مهملة).

هذه الأدوات الأولية ضرورية لفهم "أين" يعمل برنامجك وما هي طبيعة قنوات إدخاله وإخراجه القياسية. في الفصول التالية، سنتعمق في كيفية التحكم في سلوك هذه الطرفيات.

---

**الفصل الثاني: التحكم العام بالأجهزة وسمات الطرفية**

في هذا الفصل، سنتناول أدوات أكثر قوة: دالة عامة للتحكم في الأجهزة (`ioctl`)، ودوال متخصصة للتحكم الدقيق في خصائص وسلوك الطرفيات (`tcgetattr`, `tcsetattr`).

---

**4. الدالة `ioctl()` (Input/Output Control)**

*   **الغرض (Purpose):**
    الدالة `ioctl()` هي آلية نظام تشغيل يونكس للقيام بمجموعة واسعة من عمليات التحكم في الإدخال/الإخراج على الأجهزة الخاصة (special devices) أو الملفات التي تدعمها. اسمها اختصار لـ "Input/Output Control". هي بمثابة "صندوق أدوات سويسري" لمهام لا تغطيها عمليات القراءة (`read()`) والكتابة (`write()`) القياسية.

    بالنسبة للطرفيات، تُستخدم `ioctl()` للعديد من الأشياء، مثل:
    *   الحصول على أو تعيين حجم نافذة الطرفية.
    *   إرسال إشارة `BREAK`.
    *   التحكم في خطوط المودم (للطرفيات التسلسلية).
    *   جعل طرفية معينة هي الطرفية المتحكمة للعملية.
    *   والعديد من العمليات الأخرى الخاصة بالطرفيات (terminal-specific operations).

*   **التضمين (Header File):**
    ```c
    #include <sys/ioctl.h> // الملف الرئيسي لـ ioctl
    // قد تحتاج إلى تضمين ملفات أخرى حسب نوع الطلب (request)
    // مثلاً، لطلبات الطرفية، قد تحتاج إلى <termios.h> أو <sys/ttycom.h> (تعتمد على النظام)
    ```

*   **التصريح (Synopsis):**
    ```c
    int ioctl(int fd, unsigned long request, ...);
    ```

*   **المعاملات (Parameters):**
    *   `int fd`: واصف الملف للجهاز أو الملف الذي تريد التحكم فيه. يجب أن يكون هذا الواصف مفتوحاً.
    *   `unsigned long request`: رقم صحيح يحدد نوع عملية التحكم المطلوبة. هذه الأرقام عادةً ما تكون معرفة كثوابت ماكرو (macros) في ملفات الترويسة (مثل `TIOCGWINSZ` للحصول على حجم النافذة). يحدد هذا الطلب أيضاً نوع وطبيعة الوسيط الثالث (إذا وجد).
    *   `...` (النقاط الثلاث - varargs): وسيط ثالث اختياري (أو أكثر في بعض الحالات النادرة جداً). نوع هذا الوسيط يعتمد كلياً على قيمة `request`. يمكن أن يكون:
        *   مؤشر إلى عدد صحيح (e.g., `int *`).
        *   مؤشر إلى هيكل (e.g., `struct winsize *`).
        *   عدد صحيح مباشرة.
        *   أو لا شيء (إذا كان الطلب لا يتطلب وسيطاً إضافياً).

        **تحذير:** يجب أن تكون حذراً جداً لتمرير النوع الصحيح من الوسيط الثالث كما هو متوقع من قبل `request`. تمرير نوع خاطئ يمكن أن يؤدي إلى سلوك غير محدد أو انهيار البرنامج.

*   **القيمة المُرجعة (Return Value):**
    *   عند النجاح، القيمة المُرجعة تعتمد على `request`. العديد من الطلبات تُرجع `0` عند النجاح. بعضها قد يُرجع قيمة أخرى (مثل `FIONREAD` الذي يُرجع عدد البايتات المتاحة للقراءة).
    *   عند الفشل، تُرجع `ioctl()` القيمة `-1`، وتُعيّن `errno` للإشارة إلى الخطأ. الأخطاء الشائعة:
        *   `EBADF`: واصف الملف `fd` غير صالح.
        *   `ENOTTY`: الطلب `request` غير مناسب لنوع الجهاز المشار إليه بـ `fd`. (مثلاً، محاولة طلب خاص بالطرفية على ملف عادي).
        *   `EINVAL`: الطلب `request` أو الوسيط الثالث غير صالح.
        *   `EPERM`: لا تملك الصلاحيات اللازمة لتنفيذ الطلب.
        *   `EFAULT`: الوسيط الثالث (إذا كان مؤشراً) يشير إلى عنوان ذاكرة غير صالح.

*   **الشرح التفصيلي (Detailed Explanation):**
    `ioctl()` هي دالة قوية جداً ومنخفضة المستوى. كل مُشغِّل جهاز (device driver) في نواة نظام التشغيل يمكنه تسجيل قائمة بالطلبات (`request` codes) التي يفهمها. عندما تستدعي `ioctl()`، يقوم نظام التشغيل بتوجيه هذا الطلب إلى مُشغِّل الجهاز المناسب بناءً على `fd`.

    **بناء أكواد الطلبات (`request` codes):**
    أكواد الطلبات ليست مجرد أرقام عشوائية. هي عادةً ما تُبنى باستخدام ماكروهات (مثل `_IO()`, `_IOR()`, `_IOW()`, `_IOWR()`) لتضمين معلومات حول:
    *   **نوع الجهاز (Device Type):** حرف أو رقم يحدد فئة الجهاز (مثلاً, 'T' للطرفيات).
    *   **رقم الطلب (Request Number):** رقم فريد ضمن هذا النوع من الأجهزة.
    *   **اتجاه نقل البيانات (Direction of Data Transfer):**
        *   `_IO`: لا يوجد نقل بيانات (الوسيط الثالث غير مستخدم أو بسيط).
        *   `_IOR`: قراءة (Read) - البيانات تُنقل من النواة إلى مساحة المستخدم (الوسيط الثالث هو مؤشر إلى متغير سيتم ملؤه).
        *   `_IOW`: كتابة (Write) - البيانات تُنقل من مساحة المستخدم إلى النواة (الوسيط الثالث هو مؤشر إلى متغير يحتوي على بيانات لإرسالها).
        *   `_IOWR`: قراءة وكتابة (Read/Write) - البيانات تُنقل في كلا الاتجاهين.
    *   **حجم البيانات (Size of Data):** حجم الهيكل أو المتغير الذي يشير إليه الوسيط الثالث.

    هذا الترميز يساعد النواة على التحقق من صحة الوسائط وتخصيص الذاكرة بشكل آمن.

    **أمثلة على طلبات `ioctl` شائعة للطرفيات (TTY IOCTL Requests):**
    تختلف هذه الطلبات قليلاً بين أنظمة يونكس المختلفة (Linux, macOS, BSDs)، ولكن هناك مجموعة شائعة. هذه الطلبات عادةً ما تكون مُعرّفة في `<sys/ioctl.h>` أو `<termios.h>` (في Linux، الكثير منها في `<asm-generic/ioctls.h>` أو `<linux/tty.h>` والتي تُضمّن عبر الملفات القياسية).

    1.  **`TIOCGWINSZ` (Terminal IOCTL Get Window Size):**
        *   **الغرض:** الحصول على أبعاد نافذة الطرفية الحالية (عدد الصفوف والأعمدة).
        *   **الوسيط الثالث:** مؤشر إلى هيكل `struct winsize`.
            ```c
            struct winsize {
                unsigned short ws_row;    /* rows, in characters */
                unsigned short ws_col;    /* columns, in characters */
                unsigned short ws_xpixel; /* horizontal size, pixels (unused) */
                unsigned short ws_ypixel; /* vertical size, pixels (unused) */
            };
            ```
        *   **مثال:** يُستخدم بواسطة برامج مثل `vim` أو `top` لتكييف عرضها مع حجم النافذة.
        *   **ملاحظة:** عندما يُغيّر المستخدم حجم نافذة الطرفية، عادةً ما تُرسل إشارة `SIGWINCH` إلى العمليات في المقدمة. يجب على البرنامج التعامل مع هذه الإشارة ثم استدعاء `ioctl(fd, TIOCGWINSZ, &ws)` لتحديث معلومات حجم النافذة.

    2.  **`TIOCSWINSZ` (Terminal IOCTL Set Window Size):**
        *   **الغرض:** (نظرياً) تعيين أبعاد نافذة الطرفية.
        *   **الوسيط الثالث:** مؤشر إلى هيكل `struct winsize` يحتوي على الأبعاد الجديدة.
        *   **ملاحظة:** استخدام هذا الطلب لتغيير حجم النافذة فعلياً أقل شيوعاً وموثوقية من `TIOCGWINSZ`. عادةً ما يتم تغيير حجم النافذة بواسطة مدير النوافذ أو محاكي الطرفية، وليس بواسطة البرنامج الذي يعمل داخل الطرفية. ومع ذلك، قد يكون مفيداً لإعلام النواة بحجم "متوقع" أو "مفضل" للطرفيات الزائفة.

    3.  **`TCGETS` (Terminal Control Get Settings - POSIX) / `TIOCGETA` (Terminal IOCTL Get Attributes - BSD/System V):**
        *   **الغرض:** الحصول على سمات الطرفية الحالية. هذه هي نفس السمات التي تتعامل معها دوال `tcgetattr()` (سنتحدث عنها بالتفصيل لاحقاً).
        *   **الوسيط الثالث:** مؤشر إلى هيكل `struct termios` (لـ `TCGETS`) أو `struct termio` (لـ `TIOCGETA` القديمة). يُفضل استخدام `TCGETS` و `struct termios` للبرمجة المتوافقة مع POSIX.
        *   **ملاحظة:** الدالة `tcgetattr()` هي الواجهة القياسية المفضلة لهذه الوظيفة.

    4.  **`TCSETS` (Terminal Control Set Settings - POSIX) / `TIOCSETA` (Terminal IOCTL Set Attributes - BSD/System V):**
        *   **الغرض:** تعيين سمات الطرفية. هذه هي نفس السمات التي تتعامل معها دوال `tcsetattr()` (سنتحدث عنها بالتفصيل لاحقاً).
        *   **الوسيط الثالث:** مؤشر إلى هيكل `struct termios` (لـ `TCSETS`) أو `struct termio` (لـ `TIOCSETA`).
        *   **ملاحظة:** الدالة `tcsetattr()` هي الواجهة القياسية المفضلة لهذه الوظيفة. هناك متغيرات مثل `TCSETSW` (انتظر حتى يتم إرسال كل الإخراج قبل التغيير) و `TCSETSF` (مثل `TCSETSW` بالإضافة إلى مسح أي إدخال لم يُقرأ).

    5.  **`TIOCSCTTY` (Terminal IOCTL Set Controlling TTY):**
        *   **الغرض:** جعل الطرفية المحددة بـ `fd` هي الطرفية المتحكمة للعملية الحالية.
        *   **الوسيط الثالث:** عدد صحيح، عادةً `1` (أو أي قيمة غير صفرية) لتأكيد الطلب.
        *   **شروط:**
            *   يجب أن تكون العملية قائد جلسة (session leader).
            *   يجب ألا تكون العملية لديها طرفية متحكمة بالفعل.
            *   يجب أن يكون `fd` يشير إلى طرفية ليست بالفعل طرفية متحكمة لعملية أخرى.
        *   **الاستخدام:** يُستخدم بواسطة برامج مثل `login` أو مديري الجلسات.

    6.  **`TIOCNOTTY` (Terminal IOCTL No TTY):**
        *   **الغرض:** فصل العملية الحالية عن طرفيتها المتحكمة (إذا كانت لديها واحدة).
        *   **الوسيط الثالث:** لا يوجد (يُمرر `NULL` أو `0`).
        *   **الاستخدام:** يُستخدم بواسطة العمليات الخفية (daemons) لضمان عدم تفاعلها مع أي طرفية عن طريق الخطأ.

    7.  **`FIONREAD` (File IOCTL Number of Bytes to Read) / `TIOCINQ` (Terminal IOCTL Input Queue):**
        *   **الغرض:** الحصول على عدد البايتات المتوفرة للقراءة حالياً في مخزن الإدخال المؤقت للطرفية (أو الملف/الأنبوب).
        *   **الوسيط الثالث:** مؤشر إلى عدد صحيح (`int *`) حيث سيتم تخزين عدد البايتات.
        *   **القيمة المُرجعة (عند النجاح):** `0`. القيمة الفعلية تُكتب في المتغير الذي يشير إليه الوسيط الثالث.
        *   **الاستخدام:** يمكن استخدامه للتحقق مما إذا كان هناك إدخال ينتظر قبل محاولة القراءة، ولكن استخدام دوال مثل `select()`, `poll()`, `epoll()` عادة ما يكون أفضل للتعامل مع الإدخال/الإخراج غير المتزامن.

    8.  **`TIOCOUTQ` (Terminal IOCTL Output Queue):**
        *   **الغرض:** الحصول على عدد البايتات التي لا تزال في مخزن الإخراج المؤقت للطرفية تنتظر الإرسال إلى الجهاز الفعلي.
        *   **الوسيط الثالث:** مؤشر إلى عدد صحيح (`int *`).
        *   **الاستخدام:** مفيد لمعرفة ما إذا كان كل الإخراج قد تم إرساله بالفعل.

    9.  **`TIOCSTI` (Terminal IOCTL Simulate Terminal Input):**
        *   **الغرض:** إدخال (حقن) حرف في طابور إدخال الطرفية، كما لو كان المستخدم قد كتبه.
        *   **الوسيط الثالث:** مؤشر إلى الحرف (`char *`) الذي سيتم حقنه.
        *   **الأمان:** هذا الطلب خطير جداً من الناحية الأمنية! إذا تمكن برنامج غير موثوق به من استخدامه على طرفية مستخدم آخر (إذا كان لديه الصلاحيات)، فيمكنه إدخال أوامر بشكل تعسفي. لذلك، في معظم الأنظمة الحديثة، يقتصر استخدامه على العمليات التي لها صلاحيات الجذر (root) أو التي تمتلك الطرفية (`CAP_SYS_ADMIN` في Linux).

    10. **`TIOCMBIS`, `TIOCMBIC`, `TIOCMGET`, `TIOCMSET` (Modem Bits):**
        *   تُستخدم للتحكم في خطوط إشارة المودم (DTR, RTS, CTS, DCD, RI, DSR) على المنافذ التسلسلية. أقل أهمية للطرفيات الزائفة الحديثة، ولكنها حيوية عند التعامل مباشرة مع الأجهزة التسلسلية.
        *   `TIOCMGET`: الحصول على حالة خطوط المودم.
        *   `TIOCMSET`: تعيين حالة خطوط المودم.
        *   `TIOCMBIS`: تعيين بتات معينة (Set Bits).
        *   `TIOCMBIC`: مسح بتات معينة (Clear Bits).
        *   **الوسيط الثالث:** مؤشر إلى عدد صحيح (`int *`) يمثل قناع البتات.

*   **أمثلة عملية (Use Cases/Examples):**

    **مثال 1: الحصول على حجم نافذة الطرفية (`TIOCGWINSZ`)**

    ```c
    #include <stdio.h>
    #include <unistd.h>      // For STDOUT_FILENO
    #include <sys/ioctl.h>   // For ioctl(), TIOCGWINSZ
    #include <termios.h>     // For struct winsize (often included via sys/ioctl.h on Linux)
    #include <signal.h>      // For signal(), SIGWINCH
    #include <stdlib.h>      // For exit()

    void print_window_size(int fd) {
        struct winsize ws;

        if (ioctl(fd, TIOCGWINSZ, &ws) == -1) {
            perror("ioctl TIOCGWINSZ error");
            return;
        }

        printf("Window size: %d rows, %d columns\n", ws.ws_row, ws.ws_col);
        // ws_xpixel and ws_ypixel are usually not used or zero
        if (ws.ws_xpixel > 0 && ws.ws_ypixel > 0) {
             printf("Pixel size: %d x %d\n", ws.ws_xpixel, ws.ws_ypixel);
        }
    }

    // معالج إشارة SIGWINCH
    void sigwinch_handler(int signo) {
        printf("\nSIGWINCH received. Terminal resized.\n");
        // عادةً ما يكون STDOUT_FILENO أو أي واصف ملف آخر يشير إلى الطرفية
        print_window_size(STDOUT_FILENO);
        // في تطبيق حقيقي، قد تحتاج إلى إعادة رسم الشاشة هنا
    }

    int main() {
        // التحقق مما إذا كان stdout هو TTY
        if (!isatty(STDOUT_FILENO)) {
            fprintf(stderr, "Standard output is not a TTY. Window size is not applicable.\n");
            return 1;
        }

        // تسجيل معالج إشارة SIGWINCH
        if (signal(SIGWINCH, sigwinch_handler) == SIG_ERR) {
            perror("Cannot handle SIGWINCH");
            // لا نخرج، يمكننا الاستمرار بدون معالجة تغيير الحجم الديناميكي
        }

        printf("Initial check:\n");
        print_window_size(STDOUT_FILENO);

        printf("\nTry resizing your terminal window now. I will wait for 20 seconds.\n");
        printf("(You might need to press Enter or type something in some terminals to see updates if not handled by SIGWINCH)\n");

        // حلقة انتظار بسيطة لرؤية تأثير SIGWINCH
        // في تطبيق حقيقي، سيكون البرنامج يقوم بعمله هنا
        for(int i = 0; i < 20; ++i) {
            sleep(1); // انتظر ثانية واحدة
            // بعض الطرفيات لا ترسل SIGWINCH إلا عند وجود نشاط I/O
            // fflush(stdout);
        }
        
        printf("\nFinal check (after potential resizes):\n");
        print_window_size(STDOUT_FILENO);


        return 0;
    }
    ```
    **لتجربة المثال:**
    1.  **احفظ الكود** باسم `winsize.c`.
    2.  **ترجمه:** `gcc winsize.c -o winsize`
    3.  **شغله:** `./winsize`
    4.  أثناء عمل البرنامج، حاول تغيير حجم نافذة الطرفية. سترى رسالة `SIGWINCH received` (إذا كان نظامك يرسلها بشكل جيد) ويتم طباعة الحجم الجديد.

    **مثال 2: التحقق من عدد البايتات المتاحة للقراءة (`FIONREAD` أو `TIOCINQ`)**

    ```c
    #include <stdio.h>
    #include <unistd.h>    // For STDIN_FILENO, read
    #include <sys/ioctl.h> // For ioctl(), FIONREAD
    #include <termios.h>   // قد يحتوي على تعريف FIONREAD في بعض الأنظمة
                           // أو قد يكون في sys/filio.h (BSD) أو sys/ioccom.h

    #ifndef FIONREAD
    #include <sys/filio.h> // لمحاولة إيجاد FIONREAD إذا لم يكن في sys/ioctl.h
    #endif

    int main() {
        if (!isatty(STDIN_FILENO)) {
            fprintf(stderr, "stdin is not a TTY. FIONREAD test might behave differently.\n");
            // مع ذلك، FIONREAD يعمل أيضاً على الأنابيب والملفات.
        }

        printf("Type something and press Enter (or just wait for input from a pipe):\n");

        // انتظر قليلاً للسماح للمستخدم بالكتابة
        // في تطبيق حقيقي، هذا الجزء سيكون أكثر تعقيداً (مثل استخدام select/poll)
        sleep(5); // انتظر 5 ثواني

        int bytes_available;
        if (ioctl(STDIN_FILENO, FIONREAD, &bytes_available) == -1) {
            perror("ioctl FIONREAD error");
            return 1;
        }

        printf("Bytes available to read from stdin: %d\n", bytes_available);

        if (bytes_available > 0) {
            char buffer[128];
            int bytes_to_read = (bytes_available < sizeof(buffer) - 1) ? bytes_available : sizeof(buffer) - 1;
            
            printf("Attempting to read %d bytes...\n", bytes_to_read);
            ssize_t num_read = read(STDIN_FILENO, buffer, bytes_to_read);

            if (num_read == -1) {
                perror("read error");
            } else {
                buffer[num_read] = '\0'; // Null-terminate
                printf("Read %zd bytes: \"%s\"\n", num_read, buffer);
            }
        } else {
            printf("No input detected within the timeout.\n");
        }

        return 0;
    }
    ```
    **لتجربة المثال:**
    1.  **احفظ الكود** باسم `check_input.c`.
    2.  **ترجمه:** `gcc check_input.c -o check_input`
    3.  **شغله مباشرة:** `./check_input`
        اكتب بعض الأحرف واضغط Enter خلال 5 ثوانٍ.
    4.  **شغله مع توجيه:** `(sleep 2; echo "hello world") | ./check_input`
        سترى أن البرنامج يكتشف "hello world" (12 بايت شاملة السطر الجديد) بعد ثانيتين.

*   **اعتبارات هامة (Important Considerations):**
    *   **قابلية النقل (Portability):** بينما `ioctl()` نفسها قياسية، فإن أكواد الطلبات (`request` codes) الفعلية والبيانات المرتبطة بها يمكن أن تختلف بشكل كبير بين أنظمة يونكس المختلفة. الطلبات المتعلقة بـ `TIOCGWINSZ` و `TCGETS`/`TCSETS` (التي هي أساس `tcgetattr`/`tcsetattr`) هي من بين الأكثر قابلية للنقل. دائماً راجع وثائق نظامك (man pages) للطلبات المحددة.
    *   **التعقيد:** `ioctl()` هي دالة منخفضة المستوى. استخدامها بشكل غير صحيح يمكن أن يؤدي إلى نتائج غير متوقعة.
    *   **البدائل:** للتحكم في سمات الطرفية، يُفضل استخدام دوال `tcgetattr()` و `tcsetattr()` الأعلى مستوى والأكثر قابلية للنقل. `ioctl()` تظل ضرورية لمهام لا تغطيها تلك الدوال (مثل `TIOCGWINSZ`).
    *   **الأمان:** بعض طلبات `ioctl` (مثل `TIOCSTI`) تتطلب صلاحيات مرتفعة.
    *   **التعامل مع الأخطاء:** تحقق دائماً من القيمة المُرجعة لـ `ioctl()` و `errno` عند الفشل.

`ioctl()` هي أداة قوية ولكن يجب استخدامها بحذر وفهم جيد للطلب المحدد الذي تستخدمه.

---

قبل أن ننتقل إلى `tcgetattr` و `tcsetattr`، دعنا نتوقف عند دالة مساعدة عامة قد تحتاجها.

**5. الدالة `getenv()`**

*   **الغرض (Purpose):**
    تُستخدم الدالة `getenv()` للحصول على قيمة متغير بيئة (environment variable) معين. متغيرات البيئة هي أزواج من "اسم=قيمة" تُمرر إلى العمليات عند بدئها، ويمكنها التأثير على سلوك البرامج.

    في سياق الطرفيات، أهم متغير بيئة هو `TERM`. هذا المتغير يخبر البرامج بنوع الطرفية التي يتفاعلون معها (مثل `xterm-256color`, `vt100`, `linux`). هذه المعلومة حاسمة للمكتبات مثل Termcap أو Terminfo (التي سنتحدث عنها لاحقاً) لتحديد كيفية إرسال أكواد التحكم الصحيحة لمسح الشاشة، تحريك المؤشر، تغيير الألوان، إلخ، بطريقة مستقلة عن الجهاز.

*   **التضمين (Header File):**
    ```c
    #include <stdlib.h>
    ```

*   **التصريح (Synopsis):**
    ```c
    char *getenv(const char *name);
    ```

*   **المعاملات (Parameters):**
    *   `const char *name`: سلسلة نصية (null-terminated string) تحتوي على اسم متغير البيئة الذي تبحث عنه (مثلاً, `"TERM"`, `"HOME"`, `"PATH"`).

*   **القيمة المُرجعة (Return Value):**
    *   إذا تم العثور على متغير البيئة بالاسم المحدد، تُرجع الدالة مؤشراً إلى سلسلة نصية تحتوي على قيمته. **هذه السلسلة النصية جزء من "بيئة" العملية وقد يتم الكتابة فوقها إذا تم استدعاء دوال تعدل البيئة (مثل `putenv()`, `setenv()`, `unsetenv()`). إذا كنت تريد الاحتفاظ بالقيمة، يجب نسخها.**
    *   إذا لم يتم العثور على متغير البيئة بالاسم المحدد، تُرجع الدالة `NULL`.
    *   لا تُعيّن `errno` عند الفشل (عند عدم العثور على المتغير).

*   **الشرح التفصيلي (Detailed Explanation):**
    كل عملية في يونكس ترث نسخة من بيئة العملية الأم التي أنشأتها. البيئة هي مصفوفة من السلاسل النصية، كل سلسلة بالصيغة `NAME=value`. الدالة `getenv()` تبحث في هذه المصفوفة عن السلسلة التي تبدأ بـ `name` متبوعة بعلامة `=`، ثم تُرجع مؤشراً إلى الجزء الذي يلي علامة `=`.

    ```c
    // مثال على كيفية عملها (مبسط جداً)
    // extern char **environ; // متغير عام يشير إلى مصفوفة البيئة
    // char *my_getenv(const char *name) {
    //     if (name == NULL || environ == NULL) return NULL;
    //     size_t name_len = strlen(name);
    //     for (char **env_ptr = environ; *env_ptr != NULL; ++env_ptr) {
    //         if (strncmp(*env_ptr, name, name_len) == 0 && (*env_ptr)[name_len] == '=') {
    //             return &((*env_ptr)[name_len + 1]);
    //         }
    //     }
    //     return NULL;
    // }
    ```

    **متغير `TERM`:**
    عندما تتصل بطرفية (أو تفتح نافذة طرفية)، عادةً ما يقوم برنامج الطرفية (مثل `xterm`, `gnome-terminal`) أو عملية تسجيل الدخول (مثل `login`, `sshd`) بتعيين متغير البيئة `TERM` إلى قيمة تصف قدرات تلك الطرفية.
    أمثلة على قيم `TERM`:
    *   `xterm`: طرفية X Window قياسية.
    *   `xterm-256color`: طرفية X Window تدعم 256 لوناً.
    *   `vt100`, `vt220`: أنواع شائعة من الطرفيات الفيزيائية القديمة (لا تزال تُحاكى كثيراً).
    *   `linux`: الكونسول الخاص بنواة لينكس.
    *   `screen`, `tmux`: طرفيات تُستخدم داخل برامج تعدد النوافذ الطرفية.

    ستستخدم دوال `tgetent()` (التي سنتناولها لاحقاً) قيمة `TERM` للبحث في قاعدة بيانات Termcap/Terminfo.

*   **أمثلة عملية (Use Cases/Examples):**

    ```c
    #include <stdio.h>
    #include <stdlib.h> // For getenv(), exit()
    #include <string.h> // For strdup(), if needed

    int main() {
        const char *term_value;
        const char *home_value;
        const char *path_value;
        const char *non_existent_var;

        term_value = getenv("TERM");
        if (term_value != NULL) {
            printf("Terminal type (TERM): %s\n", term_value);
            // إذا كنت ستستخدم term_value لاحقاً بعد تعديلات محتملة للبيئة،
            // أو إذا كنت تريد تعديل السلسلة (getenv ترجع const char * في C++، char* في C ولكن لا يجب تعديلها)
            // char *my_term = strdup(term_value);
            // if (my_term) { /* ... use my_term ... */ free(my_term); }
        } else {
            printf("TERM environment variable is not set.\n");
        }

        home_value = getenv("HOME");
        if (home_value != NULL) {
            printf("Home directory (HOME): %s\n", home_value);
        } else {
            printf("HOME environment variable is not set.\n");
        }

        path_value = getenv("PATH");
        if (path_value != NULL) {
            printf("Execution path (PATH): %s\n", path_value);
        } else {
            printf("PATH environment variable is not set.\n");
        }

        non_existent_var = getenv("THIS_VARIABLE_DOES_NOT_EXIST_XYZ");
        if (non_existent_var == NULL) {
            printf("As expected, THIS_VARIABLE_DOES_NOT_EXIST_XYZ was not found.\n");
        } else {
            // هذا لا يجب أن يحدث
            printf("Unexpected: THIS_VARIABLE_DOES_NOT_EXIST_XYZ was found: %s\n", non_existent_var);
        }

        return 0;
    }
    ```

    **لتجربة المثال:**
    1.  **احفظ الكود** باسم `check_env.c`.
    2.  **ترجمه:** `gcc check_env.c -o check_env`
    3.  **شغله:** `./check_env`
        سترى قيم متغيرات البيئة `TERM`, `HOME`, و `PATH` الخاصة بك.
    4.  **لتغيير `TERM` للتجربة (مؤقتاً لهذه الجلسة):**
        في شل باش (bash): `export TERM=vt100`
        ثم شغل `./check_env` مرة أخرى. سترى أن `TERM` قد تغير.
        أو: `TERM=myterminal ./check_env` (يغيرها فقط لهذا الاستدعاء).

*   **اعتبارات هامة (Important Considerations):**
    *   **حالة الأحرف (Case Sensitivity):** أسماء متغيرات البيئة عادةً ما تكون حساسة لحالة الأحرف (e.g., `TERM` يختلف عن `term`).
    *   **الذاكرة:** كما ذُكر، لا تقم بتعديل السلسلة المُرجعة مباشرة. إذا كنت بحاجة إلى تعديلها أو الاحتفاظ بها بشكل دائم، انسخها باستخدام `strcpy()` (إلى مخزن مؤقت بحجم كافٍ) أو `strdup()` (الذي يخصص ذاكرة جديدة).
    *   **الأمان:** لا تثق بشكل أعمى في قيم متغيرات البيئة إذا كان برنامجك يعمل بصلاحيات مرتفعة، حيث يمكن للمستخدم (أو برنامج آخر) تعيينها إلى قيم خبيثة. قم دائماً بالتحقق من صحة القيم وتطهيرها (sanitize) إذا كانت ستُستخدم في عمليات حساسة (مثل بناء مسارات ملفات أو أوامر نظام).
    *   **`environ`:** هناك متغير عام خارجي `extern char **environ;` مُعرّف في POSIX (عادةً عبر تضمين `unistd.h`) يشير إلى مصفوفة مؤشرات البيئة. يمكن استخدامه للتكرار عبر جميع متغيرات البيئة، ولكن `getenv()` هي الطريقة المفضلة للحصول على قيمة متغير محدد.

`getenv()` هي دالة أساسية ومفيدة جداً، وخاصةً للحصول على `TERM` عند العمل مع مكتبات التحكم بالطرفية المتقدمة.

---

الآن بعد أن فهمنا `ioctl` بشكل عام و `getenv`، نحن مستعدون للغوص في الدوال القياسية للتحكم في سمات الطرفية: `tcgetattr()` و `tcsetattr()`.

---

**6. الدالة `tcgetattr()` (Terminal Control Get Attributes)**

*   **الغرض (Purpose):**
    تُستخدم الدالة `tcgetattr()` للحصول على معلمات (parameters) أو سمات (attributes) الطرفية الحالية المرتبطة بواصف ملف مفتوح يشير إلى طرفية. هذه السمات تحدد جوانب كثيرة من سلوك الطرفية، مثل:
    *   هل يتم صدى (echo) الأحرف المُدخلة؟
    *   هل الإدخال في الوضع القانوني (canonical - يُعالج سطراً بسطر، مع تحرير الأسطر) أم غير قانوني (non-canonical/raw - يُعالج الأحرف فوراً)؟
    *   ما هي الأحرف الخاصة للتحكم (مثل حرف الحذف، حرف إنهاء السطر، إلخ)؟
    *   إعدادات سرعة الاتصال (baud rate).
    *   التحكم في التدفق (flow control).
    *   وغيرها الكثير.

    عادةً ما تستدعي `tcgetattr()` للحصول على الإعدادات الحالية، ثم تعدل هذه الإعدادات، ثم تستدعي `tcsetattr()` لتطبيق التعديلات.

*   **التضمين (Header File):**
    ```c
    #include <termios.h>
    #include <unistd.h> // قد يكون ضرورياً لـ STDIN_FILENO وما شابه
    ```
    ملف `termios.h` هو المفتاح هنا، فهو يُعرّف هيكل `struct termios` وجميع الثوابت المتعلقة به.

*   **التصريح (Synopsis):**
    ```c
    int tcgetattr(int fd, struct termios *termios_p);
    ```

*   **المعاملات (Parameters):**
    *   `int fd`: واصف الملف للطرفية التي تريد الحصول على سماتها. عادةً ما يكون `STDIN_FILENO` (0)، ولكن يمكن أن يكون أي واصف ملف مفتوح على جهاز طرفية.
    *   `struct termios *termios_p`: مؤشر إلى هيكل `struct termios` ستقوم الدالة بملئه بالسمات الحالية للطرفية. يجب أن تقوم أنت بتخصيص الذاكرة لهذا الهيكل قبل تمريره.

*   **القيمة المُرجعة (Return Value):**
    *   إذا نجحت، تُرجع `tcgetattr()` القيمة `0`.
    *   إذا فشلت، تُرجع `-1`، وتُعيّن `errno` للإشارة إلى الخطأ. الأخطاء الشائعة:
        *   `EBADF`: واصف الملف `fd` غير صالح.
        *   `ENOTTY`: واصف الملف `fd` لا يشير إلى طرفية.
        *   `EINVAL`: (أقل شيوعاً هنا) قد يكون هناك مشكلة داخلية.

*   **الشرح التفصيلي (Detailed Explanation):**
    `tcgetattr()` هي الواجهة القياسية (POSIX) لعملية `ioctl()` الأساسية `TCGETS`. إنها توفر طريقة محمولة للحصول على إعدادات الطرفية.

    **هيكل `struct termios`:**
    هذا الهيكل هو قلب التحكم في الطرفية. يحتوي على عدة حقول (members) تتحكم في جوانب مختلفة من سلوكها. الحقول الرئيسية هي:
    ```c
    struct termios {
        tcflag_t c_iflag;      /* input modes - أوضاع الإدخال */
        tcflag_t c_oflag;      /* output modes - أوضاع الإخراج */
        tcflag_t c_cflag;      /* control modes - أوضاع التحكم (الأجهزة) */
        tcflag_t c_lflag;      /* local modes - أوضاع محلية (واجهة المستخدم) */
        cc_t     c_cc[NCCS];   /* control characters - أحرف التحكم الخاصة */
        // قد تكون هناك حقول إضافية لسرعات الإدخال/الإخراج
        // speed_t  c_ispeed;   /* input speed */
        // speed_t  c_ospeed;   /* output speed */
    };
    ```
    دعنا نفصل هذه الحقول:

    1.  **`tcflag_t c_iflag` (Input Modes - أوضاع الإدخال):**
        يتحكم في معالجة الإدخال. هذه أعلام (flags) يمكن دمجها باستخدام عملية `OR` الثنائية (`|`). بعض الأعلام الشائعة:
        *   `IGNBRK`: تجاهل حالة `BREAK` عند الإدخال.
        *   `BRKINT`: إذا تم تعيين `IGNBRK` ولم يتم تعيين `BRKINT`، فإن `BREAK` يُقرأ كـ `NULL` (`\0`). إذا تم تعيين `BRKINT`، فإن `BREAK` يتسبب في إرسال إشارة `SIGINT`.
        *   `IGNPAR`: تجاهل أخطاء التكافؤ (parity errors) في الإطارات.
        *   `PARMRK`: إذا تم تعيين `IGNPAR` ولم يتم تعيين `PARMRK`، فإن البايت الذي به خطأ تكافؤ يُتجاهل. إذا تم تعيين `PARMRK`، فإن البايت يُقرأ كسلسلة من 3 بايتات: `\377 \0 X` (حيث `X` هو البايت الأصلي).
        *   `INPCK`: تفعيل فحص التكافؤ للإدخال.
        *   `ISTRIP`: تجريد (إزالة) البت الثامن من كل بايت مُدخل (يصبح 7 بت).
        *   `INLCR`: ترجمة `NL` (سطر جديد) إلى `CR` (عودة إلى بداية السطر) عند الإدخال.
        *   `IGNCR`: تجاهل `CR` عند الإدخال.
        *   `ICRNL`: ترجمة `CR` إلى `NL` عند الإدخال (ما لم يتم تعيين `IGNCR`). هذا هو السلوك الشائع، حيث أن Enter عادةً ما يُرسل `CR` أو `CRLF`.
        *   `IUCLC`: (غير قياسي، مهمل) ترجمة الأحرف الكبيرة إلى صغيرة عند الإدخال.
        *   `IXON`: تفعيل التحكم في التدفق XON/XOFF (Ctrl-S, Ctrl-Q) للإخراج (الطرفية ترسل Ctrl-S لإيقاف الإرسال، Ctrl-Q لاستئنافه).
        *   `IXOFF`: تفعيل التحكم في التدفق XON/XOFF للإدخال (النظام يرسل Ctrl-S/Ctrl-Q للطرفية).
        *   `IXANY`: السماح لأي حرف بإعادة تشغيل الإخراج المتوقف (ليس فقط Ctrl-Q).
        *   `IMAXBEL`: إصدار صوت جرس (BEL, `\a`) عندما يمتلئ مخزن الإدخال المؤقت، بدلاً من تجاهل المزيد من الأحرف.

    2.  **`tcflag_t c_oflag` (Output Modes - أوضاع الإخراج):**
        يتحكم في معالجة الإخراج بعد المعالجة (post-processing).
        *   `OPOST`: تفعيل معالجة الإخراج المعتمدة على التنفيذ (implementation-defined). إذا تم تعطيل هذا، فإن جميع أعلام `c_oflag` الأخرى (باستثناء `ONLCR` في بعض الأنظمة) تُتجاهل، والأحرف تُرسل كما هي ("raw output").
        *   `OLCUC`: (غير قياسي، مهمل) ترجمة الأحرف الصغيرة إلى كبيرة عند الإخراج.
        *   `ONLCR`: (XSI) ترجمة `NL` إلى `CR-NL` عند الإخراج. هذا يجعل Enter (الذي يُرسل عادةً `NL` بواسطة البرامج) يحرك المؤشر إلى بداية السطر التالي.
        *   `OCRNL`: ترجمة `CR` إلى `NL` عند الإخراج.
        *   `ONOCR`: عدم إخراج `CR` عند العمود 0.
        *   `ONLRET`: عدم إرسال `CR` (حرف `NL` يفترض أنه يقوم بوظيفة العودة لبداية السطر).
        *   `OFILL`: إرسال أحرف حشو (fill characters) للتأخير بدلاً من استخدام تأخيرات زمنية.
        *   `OFDEL`: استخدام حرف الحذف (DEL, ASCII 127) كحرف حشو. إذا لم يُعيّن، يُستخدم `NUL` (ASCII 0).
        *   `NLDLY`, `CRDLY`, `TABDLY`, `BSDLY`, `VTDLY`, `FFDLY`: أعلام لتحديد تأخيرات (delays) بعد `NL`, `CR`, `TAB`, `BS` (Backspace), `VT` (Vertical Tab), `FF` (Form Feed). تُستخدم مع قيم مثل `NL0`, `NL1`, `CR0`, `CR1`, إلخ. هذه أقل أهمية للطرفيات الحديثة السريعة.

    3.  **`tcflag_t c_cflag` (Control Modes - أوضاع التحكم):**
        يتحكم في معلمات الأجهزة الخاصة بالطرفية (مثل حجم البايت، التكافؤ، عدد بتات التوقف، سرعة الاتصال).
        *   `CBAUD`: (ليس POSIX) قناع لبتات سرعة الاتصال (Baud rate).
        *   `B0`, `B50`, `B75`, `B110`, ..., `B38400`, `B57600`, `B115200`, `B230400`, ...: ثوابت لسرعات الاتصال. تُستخدم مع دوال `cfsetispeed()`, `cfsetospeed()`, `cfgetispeed()`, `cfgetospeed()` لتعيين/الحصول على السرعات. (ملاحظة: سرعات الإدخال/الإخراج قد تكون مخزنة في `c_ispeed`/`c_ospeed` أو مرمزة داخل `c_cflag` في بعض الأنظمة القديمة).
        *   `CSIZE`: قناع لحجم الحرف (عدد البتات لكل بايت). يُستخدم مع:
            *   `CS5`: 5 بتات لكل بايت.
            *   `CS6`: 6 بتات.
            *   `CS7`: 7 بتات.
            *   `CS8`: 8 بتات. (الأكثر شيوعاً)
        *   `CSTOPB`: تعيين بتي توقف (stop bits) بدلاً من واحد.
        *   `CREAD`: تفعيل مستقبل (receiver) الإدخال.
        *   `PARENB`: تفعيل توليد التكافؤ عند الإخراج والتحقق منه عند الإدخال.
        *   `PARODD`: استخدام تكافؤ فردي (odd parity). إذا لم يُعيّن و `PARENB` مُعيّن، يُستخدم تكافؤ زوجي (even parity).
        *   `HUPCL`: إرسال إشارة قطع الاتصال (hangup signal - `SIGHUP`) إلى خط المودم عند إغلاق آخر عملية للطرفية.
        *   `CLOCAL`: تجاهل خطوط التحكم في المودم (مثل Carrier Detect). يعني أن الاتصال "محلي" ولا يتطلب مودم. مهم للطرفيات الزائفة والكونسول.
        *   `CRTSCTS`: (ليس POSIX، لكنه شائع) تفعيل التحكم في التدفق بالأجهزة RTS/CTS.

    4.  **`tcflag_t c_lflag` (Local Modes - أوضاع محلية):**
        يتحكم في وظائف واجهة المستخدم للطرفية.
        *   `ISIG`: عند تلقي أي من الأحرف `INTR`, `QUIT`, `SUSP`, أو `DSUSP` (المعرفة في `c_cc`)، يتم توليد الإشارة المقابلة (`SIGINT`, `SIGQUIT`, `SIGTSTP`, `SIGTTIN`/`SIGTTOU` لـ `DSUSP` عند قراءة/كتابة عملية في الخلفية).
        *   `ICANON`: تفعيل الوضع القانوني (Canonical Mode). هذا هو الوضع "المطبوخ" أو "سطر بسطر".
            *   **في الوضع القانوني:** الإدخال يُجمع في مخزن مؤقت حتى يتم تلقي حرف فاصل للسطر (`EOL`, `EOL2`, أو `EOF` من `c_cc`). يمكن للمستخدم تحرير السطر باستخدام أحرف `ERASE` و `KILL` قبل إرساله. الإدخال لا يُتاح للبرنامج إلا بعد إرسال السطر. الحد الأقصى لطول السطر هو `MAX_CANON`.
            *   **في الوضع غير القانوني (إذا لم يُعيّن `ICANON`):** الإدخال يُتاح للبرنامج فوراً (أو بعد عدد معين من الأحرف أو مهلة زمنية، انظر `VMIN` و `VTIME` في `c_cc`). لا يوجد تحرير للأسطر مدمج. يُسمى أحياناً "الوضع الخام" (Raw Mode)، على الرغم من أن الوضع الخام الحقيقي يتضمن أيضاً تعطيل معالجة الإدخال/الإخراج الخاصة (`OPOST`, إلخ).
        *   `XCASE`: (ليس POSIX، مهمل) إذا تم تعيين `ICANON`، فإن الأحرف الكبيرة تُسبق بـ `\` عند الإدخال/الإخراج (للطرفيات التي تدعم الأحرف الكبيرة فقط).
        *   `ECHO`: صدى (عرض) أحرف الإدخال مرة أخرى إلى الطرفية. مهم لإيقافه عند قراءة كلمات المرور.
        *   `ECHOE`: إذا تم تعيين `ICANON` و `ECHO`، فإن حرف `ERASE` يمحو الحرف السابق (بإرسال تسلسل Backspace-Space-Backspace).
        *   `ECHOK`: إذا تم تعيين `ICANON` و `ECHO`، فإن حرف `KILL` يمحو السطر الحالي بأكمله (بطريقة تعتمد على النظام).
        *   `ECHONL`: إذا تم تعيين `ICANON`، يتم صدى حرف `NL` حتى لو لم يتم تعيين `ECHO`. مفيد للسماح للمستخدم برؤية أن السطر قد تم إدخاله.
        *   `NOFLSH`: تعطيل مسح (flushing) طوابير الإدخال/الإخراج عند توليد إشارات `SIGINT`, `SIGQUIT`, `SIGTSTP`.
        *   `TOSTOP`: إرسال إشارة `SIGTTOU` إلى عمليات الخلفية التي تحاول الكتابة إلى الطرفية المتحكمة. هذا يوقفها.
        *   `ECHOCTL`: (ليس POSIX، لكنه شائع) إذا تم تعيين `ECHO`، يتم صدى أحرف التحكم (ASCII 0-31) كـ `^X` (مثلاً, Ctrl-C كـ `^C`) بدلاً من إرسالها مباشرة (مما قد يؤدي إلى سلوك غريب).
        *   `ECHOPRT`: (ليس POSIX) إذا تم تعيين `ICANON` و `ECHO`، فإن الأحرف تُطبع أثناء محوها (للطرفيات الورقية القديمة).
        *   `ECHOKE`: (ليس POSIX) إذا تم تعيين `ICANON`، فإن `KILL` يمحو السطر بطريقة أكثر شمولاً (مثل `ECHOE` و `ECHOK` معاً).
        *   `FLUSHO`: (ليس POSIX، يتم التحكم فيه بـ `Ctrl-O`) الإخراج يُمسح. الكتابة إلى الطرفية تتجاهل الإخراج حتى يتم إلغاء تعيين هذا العلم مرة أخرى.
        *   `PENDIN`: (ليس POSIX، حالة داخلية) أي إدخال لم يُقرأ بعد إعادة طبعه (بعد `Ctrl-W` مثلاً).
        *   `IEXTEN`: تفعيل وظائف خاصة بالإدخال مُعرّفة بالتنفيذ (implementation-defined). مثلاً، على لينكس، هذا يفعّل التعرف على `LNEXT` (Ctrl-V) و `WERASE` (Ctrl-W). تعطيله قد يكون جزءاً من تحقيق "الوضع الخام الحقيقي".

    5.  **`cc_t c_cc[NCCS]` (Control Characters - أحرف التحكم):**
        مصفوفة من الأحرف الخاصة التي لها معنى خاص في معالجة الطرفية. `NCCS` هو ثابت يحدد حجم هذه المصفوفة. كل عنصر في المصفوفة هو `cc_t` (عادةً `unsigned char`). الفهارس لهذه المصفوفة هي ثوابت مثل:
        *   `VINTR` (Interrupt): الحرف الذي يولد إشارة `SIGINT` (عادةً Ctrl-C).
        *   `VQUIT` (Quit): الحرف الذي يولد إشارة `SIGQUIT` (عادةً Ctrl-\).
        *   `VERASE` (Erase): الحرف الذي يمحو آخر حرف تم إدخاله في الوضع القانوني (عادةً Backspace أو Delete).
        *   `VKILL` (Kill): الحرف الذي يمحو السطر الحالي بأكمله في الوضع القانوني (عادةً Ctrl-U).
        *   `VEOF` (End-Of-File): الحرف الذي يشير إلى نهاية الإدخال (عادةً Ctrl-D). في الوضع القانوني، إذا كان هذا هو الحرف الأول في السطر، فإنه يتسبب في أن تُرجع `read()` القيمة 0.
        *   `VTIME` (Time): مهلة زمنية بالديسي ثانية (أعشار الثانية) للقراءة في الوضع غير القانوني.
            *   إذا `VMIN > 0` و `VTIME > 0`: `VTIME` هي مهلة بين الأحرف. تبدأ الساعة بعد استلام الحرف الأول. إذا انقضت المهلة قبل استلام الحرف التالي، أو قبل استلام `VMIN` من الأحرف، تُرجع `read()` الأحرف التي تم تلقيها حتى الآن.
            *   إذا `VMIN > 0` و `VTIME = 0`: `read()` تنتظر (تحجب) إلى أجل غير مسمى حتى يتم تلقي `VMIN` من الأحرف.
            *   إذا `VMIN = 0` و `VTIME > 0`: `VTIME` هي مهلة قراءة. `read()` تنتظر لمدة `VTIME` أعشار الثانية. إذا تم تلقي أي أحرف خلال هذه الفترة، تُرجعها `read()` فوراً. إذا لم يتم تلقي أي أحرف، تُرجع `read()` القيمة 0.
            *   إذا `VMIN = 0` و `VTIME = 0`: `read()` تُرجع فوراً. إذا كانت هناك أحرف متاحة، تُرجعها. إذا لم تكن هناك، تُرجع 0. (قراءة غير محجوبة - non-blocking read).
        *   `VMIN` (Minimum): الحد الأدنى لعدد الأحرف المطلوب للقراءة في الوضع غير القانوني. (انظر الشرح أعلاه مع `VTIME`).
        *   `VSWTC`: (غير مستخدم في POSIX، من System V) حرف تبديل الصدفة (Shell layer switch).
        *   `VSTART` (Start): الحرف الذي يستأنف الإخراج المتوقف بواسطة `VSTOP` (عادةً Ctrl-Q). يُستخدم إذا تم تعيين `IXON`.
        *   `VSTOP` (Stop): الحرف الذي يوقف الإخراج (عادةً Ctrl-S). يُستخدم إذا تم تعيين `IXON`.
        *   `VSUSP` (Suspend): الحرف الذي يولد إشارة `SIGTSTP` (عادةً Ctrl-Z).
        *   `VEOL` (End-Of-Line): حرف إضافي لإنهاء السطر في الوضع القانوني (بالإضافة إلى `NL`).
        *   `VREPRINT` (Reprint): (ليس POSIX) الحرف الذي يعيد طباعة السطر الحالي غير المُدخل (عادةً Ctrl-R).
        *   `VDISCARD` (Discard): (ليس POSIX، يُسمى `VFLUSHO` في بعض الأنظمة) الحرف الذي يبدل حالة مسح الإخراج (عادةً Ctrl-O).
        *   `VWERASE` (Word Erase): (ليس POSIX) الحرف الذي يمحو الكلمة السابقة في الوضع القانوني (عادةً Ctrl-W).
        *   `VLNEXT` (Literal Next): (ليس POSIX) الحرف الذي يُدخل الحرف التالي حرفياً (يتجاوز معناه الخاص) في الوضع القانوني (عادةً Ctrl-V).
        *   `VEOL2`: حرف إضافي ثانٍ لإنهاء السطر في الوضع القانوني.

        لتعطيل أحد أحرف التحكم الخاصة هذه، يمكنك تعيين قيمته إلى `_POSIX_VDISABLE`.

    **الحصول على السرعات (Baud Rates):**
    تُستخدم الدوال `cfgetispeed()` و `cfgetospeed()` للحصول على سرعات الإدخال والإخراج من هيكل `termios`.
    ```c
    speed_t cfgetispeed(const struct termios *termios_p);
    speed_t cfgetospeed(const struct termios *termios_p);
    ```
    تُرجع هذه الدوال قيمة من نوع `speed_t` (عادةً `unsigned int`) تمثل السرعة (مثل `B9600`, `B38400`).

*   **أمثلة عملية (Use Cases/Examples):**

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <termios.h>
    #include <errno.h>
    #include <string.h> // For strerror

    void print_termios_details(const struct termios *ts) {
        printf("--- termios settings ---\n");
        printf("c_iflag (Input Modes): 0x%lX\n", (unsigned long)ts->c_iflag);
        // يمكنك التحقق من أعلام محددة هنا، مثلاً:
        if (ts->c_iflag & ICRNL) printf("  ICRNL (Translate CR to NL on input) is SET\n");
        if (ts->c_iflag & IXON)  printf("  IXON (Enable XON/XOFF flow control on output) is SET\n");

        printf("c_oflag (Output Modes): 0x%lX\n", (unsigned long)ts->c_oflag);
        if (ts->c_oflag & OPOST) printf("  OPOST (Enable output processing) is SET\n");
        if (ts->c_oflag & ONLCR) printf("  ONLCR (Map NL to CR-NL on output) is SET\n");

        printf("c_cflag (Control Modes): 0x%lX\n", (unsigned long)ts->c_cflag);
        printf("  Baud rate: input %u, output %u\n", cfgetispeed(ts), cfgetospeed(ts));
        // يمكنك فك رموز CSIZE, PARENB, إلخ.
        printf("  Character size: ");
        switch (ts->c_cflag & CSIZE) {
            case CS5: printf("5 bits\n"); break;
            case CS6: printf("6 bits\n"); break;
            case CS7: printf("7 bits\n"); break;
            case CS8: printf("8 bits\n"); break;
            default: printf("unknown\n"); break;
        }
        if (ts->c_cflag & PARENB) printf("  PARENB (Parity enable) is SET\n");
        if (ts->c_cflag & CLOCAL) printf("  CLOCAL (Local line, no modem control) is SET\n");


        printf("c_lflag (Local Modes): 0x%lX\n", (unsigned long)ts->c_lflag);
        if (ts->c_lflag & ICANON) printf("  ICANON (Canonical mode) is SET\n");
        if (ts->c_lflag & ECHO)   printf("  ECHO (Echo input characters) is SET\n");
        if (ts->c_lflag & ISIG)   printf("  ISIG (Enable signals) is SET\n");
        if (ts->c_lflag & IEXTEN) printf("  IEXTEN (Enable implementation-defined input processing) is SET\n");

        printf("c_cc (Control Characters):\n");
        printf("  VINTR (Ctrl-C): %d (0x%X)\n", ts->c_cc[VINTR], ts->c_cc[VINTR]);
        printf("  VEOF (Ctrl-D): %d (0x%X)\n", ts->c_cc[VEOF], ts->c_cc[VEOF]);
        printf("  VERASE (Backspace): %d (0x%X)\n", ts->c_cc[VERASE], ts->c_cc[VERASE]);
        printf("  VKILL (Ctrl-U): %d (0x%X)\n", ts->c_cc[VKILL], ts->c_cc[VKILL]);
        printf("  VMIN: %d\n", ts->c_cc[VMIN]);
        printf("  VTIME: %d\n", ts->c_cc[VTIME]);
        // ... يمكنك طباعة المزيد من أحرف c_cc
        printf("------------------------\n");
    }

    int main() {
        struct termios original_termios;
        int fd_terminal;

        // حاول استخدام stdin. إذا لم يكن طرفية، حاول فتح /dev/tty
        if (isatty(STDIN_FILENO)) {
            fd_terminal = STDIN_FILENO;
            printf("Using stdin as terminal.\n");
        } else {
            printf("stdin is not a TTY. Attempting to open /dev/tty...\n");
            fd_terminal = open("/dev/tty", O_RDWR);
            if (fd_terminal == -1) {
                perror("Failed to open /dev/tty");
                fprintf(stderr, "This program needs a terminal to get attributes from.\n");
                return 1;
            }
             printf("Using /dev/tty as terminal.\n");
        }


        // الحصول على سمات الطرفية الحالية
        if (tcgetattr(fd_terminal, &original_termios) == -1) {
            fprintf(stderr, "tcgetattr failed on fd %d: %s\n", fd_terminal, strerror(errno));
            if (fd_terminal != STDIN_FILENO) close(fd_terminal);
            return 1;
        }

        printf("Successfully retrieved terminal attributes.\n");
        print_termios_details(&original_termios);

        // (في برنامج حقيقي، قد تقوم بتعديل original_termios هنا ثم تستخدم tcsetattr)

        if (fd_terminal != STDIN_FILENO) {
            close(fd_terminal);
        }
        return 0;
    }
    ```
    **لتجربة المثال:**
    1.  **احفظ الكود** باسم `get_attrs.c`.
    2.  **ترجمه:** `gcc get_attrs.c -o get_attrs`
    3.  **شغله مباشرة:** `./get_attrs`
        سترى تفاصيل إعدادات الطرفية الحالية.
    4.  **شغله مع إعادة توجيه stdin (لترى كيف يحاول فتح `/dev/tty`):**
        `echo "test" | ./get_attrs`

*   **اعتبارات هامة (Important Considerations):**
    *   **الأهمية:** `tcgetattr()` هي الخطوة الأولى والأساسية لأي برنامج يريد تعديل سلوك الطرفية (مثل برامج تحرير النصوص، الألعاب النصية، برامج قراءة كلمات المرور).
    *   **الحفظ والاستعادة:** من الممارسات الجيدة جداً أن يقوم برنامجك بحفظ إعدادات الطرفية الأصلية التي حصل عليها باستخدام `tcgetattr()` في بداية تشغيله، ثم استعادة هذه الإعدادات الأصلية عند الخروج (سواء بشكل طبيعي أو بسبب خطأ أو إشارة) باستخدام `tcsetattr()`. هذا يضمن أن الطرفية تُترك في حالة قابلة للاستخدام للمستخدم.
    *   **التفاصيل:** عالم `termios` واسع جداً. الوثائق (man pages لـ `termios(3)`) هي صديقك المفضل هنا.

---

**7. الدالة `tcsetattr()` (Terminal Control Set Attributes)**

*   **الغرض (Purpose):**
    تُستخدم الدالة `tcsetattr()` لتعيين معلمات (سمات) الطرفية المرتبطة بواصف ملف مفتوح يشير إلى طرفية. هذه هي الدالة المكملة لـ `tcgetattr()`. بعد الحصول على السمات الحالية وتعديلها، تستخدم `tcsetattr()` لتطبيق هذه التعديلات.

*   **التضمين (Header File):**
    ```c
    #include <termios.h>
    #include <unistd.h>
    ```

*   **التصريح (Synopsis):**
    ```c
    int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
    ```

*   **المعاملات (Parameters):**
    *   `int fd`: واصف الملف للطرفية التي تريد تعيين سماتها.
    *   `int optional_actions`: يحدد متى يتم تطبيق التغييرات. يجب أن يكون أحد الثوابت التالية:
        *   `TCSANOW`: تطبيق التغييرات فوراً.
        *   `TCSADRAIN`: تطبيق التغييرات بعد أن يتم إرسال (drain) كل الإخراج المكتوب إلى `fd` حالياً. يُستخدم هذا عندما تريد التأكد من أن الإخراج الحالي لا يتأثر بالإعدادات الجديدة (مثلاً، تغيير سرعة الاتصال).
        *   `TCSAFLUSH`: تطبيق التغييرات بعد أن يتم إرسال كل الإخراج المكتوب إلى `fd`، ويتم أيضاً تجاهل (flush) أي إدخال تم تلقيه ولم يُقرأ بعد. يُستخدم هذا عندما تريد البدء "نظيفاً" مع الإعدادات الجديدة (مثلاً، عند التبديل إلى وضع مختلف قد يجعل الإدخال القديم غير ذي معنى).

    *   `const struct termios *termios_p`: مؤشر إلى هيكل `struct termios` يحتوي على السمات الجديدة التي تريد تطبيقها. عادةً ما يكون هذا الهيكل هو نفسه الذي تم ملؤه بواسطة `tcgetattr()` ثم تم تعديله.

*   **القيمة المُرجعة (Return Value):**
    *   إذا نجحت، تُرجع `tcsetattr()` القيمة `0`.
    *   إذا فشلت، تُرجع `-1`، وتُعيّن `errno` للإشارة إلى الخطأ. الأخطاء الشائعة:
        *   `EBADF`: واصف الملف `fd` غير صالح.
        *   `ENOTTY`: واصف الملف `fd` لا يشير إلى طرفية.
        *   `EINVAL`: قيمة `optional_actions` غير صالحة، أو أن أحد الحقول في `termios_p` غير صالح أو غير مدعوم.
        *   `EIO`: (خطأ إدخال/إخراج منخفض المستوى) قد يحدث إذا حاولت عملية في الخلفية تعيين سمات الطرفية ولم يُسمح لها.

*   **الشرح التفصيلي (Detailed Explanation):**
    `tcsetattr()` هي الواجهة القياسية (POSIX) لعمليات `ioctl()` الأساسية `TCSETS`, `TCSETSW`, و `TCSETSF`.

    **النمط الشائع للاستخدام:**
    1.  احصل على إعدادات الطرفية الحالية باستخدام `tcgetattr()` وخزنها في هيكل `termios` (مثلاً, `original_settings`).
    2.  قم بعمل نسخة من هذا الهيكل (مثلاً, `new_settings = original_settings`).
    3.  عدّل الحقول المطلوبة في `new_settings` (مثل تعطيل `ICANON` و `ECHO`).
    4.  طبّق الإعدادات الجديدة باستخدام `tcsetattr(fd, TCSAFLUSH, &new_settings)`.
    5.  قم بعملك الذي يتطلب هذه الإعدادات الخاصة.
    6.  **مهم جداً:** قبل خروج البرنامج (أو عند تلقي إشارات إنهاء)، استعد إعدادات الطرفية الأصلية: `tcsetattr(fd, TCSANOW, &original_settings)`.

    **مثال على التعديلات الشائعة:**

    *   **تعطيل الوضع القانوني والصدى (لـ "raw" أو "cbreak" mode):**
        ```c
        struct termios raw_settings;
        // ... tcgetattr(fd, &raw_settings); ...
        raw_settings.c_lflag &= ~(ICANON | ECHO); // تعطيل القانوني والصدى
        // قد تحتاج أيضاً إلى تعطيل ISIG, IEXTEN
        // raw_settings.c_lflag &= ~(ISIG | IEXTEN);
        // وتعطيل معالجة الإدخال الخاصة
        // raw_settings.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
        // وتعطيل معالجة الإخراج
        // raw_settings.c_oflag &= ~(OPOST);
        // وضبط VMIN و VTIME للتحكم في سلوك القراءة
        raw_settings.c_cc[VMIN] = 1;  // اقرأ حرفاً واحداً على الأقل
        raw_settings.c_cc[VTIME] = 0; // لا يوجد مهلة بين الأحرف (انتظر إلى أجل غير مسمى)
        // ... tcsetattr(fd, TCSAFLUSH, &raw_settings); ...
        ```
        الوضع "cbreak" (أقل صرامة من "raw") عادةً ما يبقي على `ISIG` مفعلاً (لتظل Ctrl-C تعمل) ويتجنب تعطيل كل شيء في `c_iflag` و `c_oflag`.

    *   **تعطيل الصدى فقط (لقراءة كلمة مرور):**
        ```c
        struct termios pass_settings;
        // ... tcgetattr(fd, &pass_settings); ...
        pass_settings.c_lflag &= ~(ECHO);
        // ... tcsetattr(fd, TCSANOW, &pass_settings); ...
        // ... اقرأ كلمة المرور ...
        // ... استعد الإعدادات الأصلية فوراً ...
        ```

    **اختيار `optional_actions`:**
    *   `TCSANOW`: يُستخدم عندما لا يهم إذا تم تطبيق التغييرات أثناء وجود إخراج/إدخال معلق. مناسب لتغييرات بسيطة مثل إيقاف الصدى مؤقتاً.
    *   `TCSADRAIN`: يُستخدم عندما تكون التغييرات قد تؤثر على تفسير الإخراج اللاحق (مثل تغيير سرعة الاتصال، أو تمكين/تعطيل `OPOST`). يضمن أن كل الإخراج الحالي يُرسل بالإعدادات القديمة.
    *   `TCSAFLUSH`: الأكثر أماناً عند تغيير جذري في وضع التشغيل (مثل الانتقال من/إلى الوضع القانوني/الخام). يضمن أنك تبدأ بحالة نظيفة دون إدخال قديم قد يُفسر بشكل خاطئ بالإعدادات الجديدة.

    **تعيين سرعات الاتصال (Baud Rates):**
    تُستخدم الدوال `cfsetispeed()` و `cfsetospeed()` لتعيين سرعات الإدخال والإخراج في هيكل `termios` *قبل* استدعاء `tcsetattr()`.
    ```c
    int cfsetispeed(struct termios *termios_p, speed_t speed);
    int cfsetospeed(struct termios *termios_p, speed_t speed);
    // speed هو ثابت مثل B9600, B38400
    // تُرجع 0 عند النجاح, -1 عند الفشل (إذا كانت السرعة غير مدعومة).
    ```
    مثال:
    ```c
    struct termios my_termios;
    // ... tcgetattr(fd, &my_termios); ...
    cfsetispeed(&my_termios, B9600);
    cfsetospeed(&my_termios, B9600);
    // ... tcsetattr(fd, TCSANOW, &my_termios); ...
    ```
    ملاحظة: تعيين سرعة الاتصال عادةً ما يكون ذا معنى فقط للطرفيات التسلسلية الفعلية، وليس للطرفيات الزائفة أو الكونسول.

    **إرسال `BREAK`:**
    الدالة `tcsendbreak(int fd, int duration)` تُستخدم لإرسال تسلسل من البتات الصفرية (حالة `BREAK`) لمدة معينة على خط تسلسلي غير متزامن.
    *   إذا كانت `duration` هي `0`، فإن الإرسال يكون لمدة بين 0.25 و 0.5 ثانية.
    *   إذا كانت `duration` غير صفرية (في بعض الأنظمة)، فإنها تحدد مدة بالمللي ثانية (يعتمد على التنفيذ).

*   **أمثلة عملية (Use Cases/Examples):**

    **مثال 1: برنامج يقرأ حرفاً واحداً في كل مرة بدون صدى (وضع cbreak بسيط)**

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <termios.h>
    #include <string.h> // For strerror
    #include <signal.h> // For signal handling

    struct termios original_termios;
    int terminal_fd = STDIN_FILENO; // افتراضياً stdin

    void restore_terminal_settings(void) {
        if (tcsetattr(terminal_fd, TCSANOW, &original_termios) == -1) {
            perror("tcsetattr (restoring original settings)");
        }
        printf("\nTerminal settings restored.\n");
    }

    void handle_signal(int signo) {
        // استعادة إعدادات الطرفية ثم الخروج
        restore_terminal_settings();
        // إعادة تعيين معالج الإشارة إلى الافتراضي والخروج
        signal(signo, SIG_DFL);
        raise(signo); // أعد إرسال الإشارة لنفسك لإنهاء البرنامج بالإشارة الأصلية
    }


    int main() {
        struct termios new_termios;
        char ch;

        if (!isatty(terminal_fd)) {
            fprintf(stderr, "Not a TTY. This program requires a terminal.\n");
            return 1;
        }

        // الحصول على الإعدادات الأصلية وحفظها
        if (tcgetattr(terminal_fd, &original_termios) == -1) {
            perror("tcgetattr");
            return 1;
        }
        
        // تسجيل دالة الاستعادة عند الخروج الطبيعي
        atexit(restore_terminal_settings);
        // تسجيل معالجات الإشارات لاستعادة الإعدادات عند الإنهاء غير الطبيعي
        signal(SIGINT, handle_signal);  // Ctrl-C
        signal(SIGTERM, handle_signal); // kill
        signal(SIGQUIT, handle_signal); // Ctrl-\
        signal(SIGHUP, handle_signal);  // Hangup

        // عمل نسخة من الإعدادات لتعديلها
        new_termios = original_termios;

        // --- تعديل الإعدادات لوضع cbreak ---
        // تعطيل الوضع القانوني (ICANON) -> قراءة حرف بحرف
        // تعطيل الصدى (ECHO) -> الأحرف لا تظهر عند كتابتها
        new_termios.c_lflag &= ~(ICANON | ECHO);

        // تعطيل ISIG للسماح بقراءة Ctrl-C كحرف عادي (اختياري، قد لا ترغب بهذا)
        // إذا عطلته، لن تتمكن من إيقاف البرنامج بـ Ctrl-C إلا إذا كان البرنامج نفسه يتحقق من هذا الحرف
        // new_termios.c_lflag &= ~ISIG; 

        // إعدادات VMIN و VTIME للتحكم في سلوك القراءة
        // VMIN = 1: انتظر حرفاً واحداً على الأقل
        // VTIME = 0: لا يوجد مهلة (انتظر إلى أجل غير مسمى للحرف)
        new_termios.c_cc[VMIN] = 1;
        new_termios.c_cc[VTIME] = 0;

        // تطبيق الإعدادات الجديدة
        // TCSAFLUSH: طبق بعد إرسال الإخراج، وتجاهل الإدخال المعلق
        if (tcsetattr(terminal_fd, TCSAFLUSH, &new_termios) == -1) {
            perror("tcsetattr (setting new settings)");
            return 1; // لا حاجة لاستدعاء restore_terminal_settings هنا لأن atexit سيفعل ذلك
        }

        printf("Terminal in cbreak mode (no echo, char-by-char input).\n");
        printf("Press 'q' to quit. Other characters will be printed with their ASCII value.\n");

        while (1) {
            ssize_t bytes_read = read(terminal_fd, &ch, 1);
            if (bytes_read == -1) {
                perror("read");
                break; // الخروج من الحلقة سيؤدي إلى استدعاء restore_terminal_settings عبر atexit
            }
            if (bytes_read == 0) { // EOF (مثلاً, إذا تم إغلاق الطرفية)
                printf("EOF received.\n");
                break;
            }

            if (ch == 'q' || ch == 'Q') {
                break;
            } else if (ch == 3) { // Ctrl-C إذا تم تعطيل ISIG
                 printf("Ctrl-C pressed (ASCII 3). If ISIG was disabled.\n");
                 // إذا كان ISIG معطل، يجب أن تخرج من هنا إذا أردت أن يكون Ctrl-C مخرجاً
                 // break; 
            }
            else {
                // طباعة الحرف وقيمته
                if (ch >= 32 && ch <= 126) { // الأحرف القابلة للطباعة
                    printf("Read: '%c' (ASCII: %d)\n", ch, ch);
                } else {
                    printf("Read: (non-printable) (ASCII: %d)\n", ch);
                }
            }
        }

        // دالة restore_terminal_settings ستُستدعى تلقائياً عند الخروج
        // عبر atexit (أو handle_signal إذا تم الإنهاء بإشارة).
        // ومع ذلك، من الجيد استدعاؤها صراحة إذا كان الخروج طبيعياً
        // قبل انتهاء main، لتكون أكثر وضوحاً.
        // atexit يضمن التنفيذ حتى لو نسيتها هنا.
        // restore_terminal_settings(); // يمكن إضافتها هنا ولكن atexit يغطيها.

        return 0;
    }
    ```

    **لتجربة المثال:**
    1.  **احفظ الكود** باسم `cbreak_input.c`.
    2.  **ترجمه:** `gcc cbreak_input.c -o cbreak_input`
    3.  **شغله:** `./cbreak_input`
        ستلاحظ أن الأحرف التي تكتبها لا تظهر على الشاشة. كل حرف يُقرأ فوراً. اضغط 'q' للخروج. إذا ضغطت Ctrl-C، يجب أن ينهي البرنامج ويعيد الطرفية لحالتها الطبيعية (بفضل `handle_signal` و `atexit`).

*   **اعتبارات هامة (Important Considerations):**
    *   **الاستعادة أمر بالغ الأهمية:** الفشل في استعادة إعدادات الطرفية الأصلية يمكن أن يترك طرفية المستخدم في حالة غير قابلة للاستخدام (مثلاً، لا يوجد صدى للأحرف، أو Enter لا يعمل). استخدم `atexit()` ومعالجات الإشارات (`signal()`) لضمان الاستعادة قدر الإمكان.
    *   **الأمان مع `TCSAFLUSH`:** كن حذراً عند استخدام `TCSAFLUSH` إذا كان هناك احتمال أن يكون المستخدم قد كتب شيئاً مهماً (مثل كلمة مرور) لم يقرأه برنامجك بعد. هذا الإدخال سيتم تجاهله.
    *   **التحقق من الأخطاء:** دائماً تحقق من القيمة المُرجعة لـ `tcsetattr()` و `errno`.
    *   **الاستخدام التدريجي:** عند بناء وضع "خام" أو "cbreak"، ابدأ بتعديلات بسيطة واختبرها. تعطيل `ICANON` و `ECHO` هو البداية المعتادة. ثم، إذا لزم الأمر، يمكنك تعديل `VMIN`/`VTIME`، أو تعطيل `ISIG`، أو معالجة `c_iflag` / `c_oflag`.
    *   **قراءة المزيد:** وثائق `termios(3)` هي مصدر لا غنى عنه لفهم جميع الأعلام بالتفصيل.

بهذا نكون قد غطينا الدوال الأساسية للتحكم في سمات الطرفية. إنها أدوات قوية تسمح لك بتخصيص تفاعل برنامجك مع المستخدم بشكل دقيق.

---

**الفصل الثالث: مكتبة Termcap (والتمهيد لـ Terminfo)**

في الأيام الأولى ليونكس، كانت هناك أنواع كثيرة ومختلفة من الطرفيات، كل منها له مجموعة فريدة من "تسلسلات الهروب" (escape sequences) لأداء عمليات مثل تحريك المؤشر، مسح الشاشة، تغيير الألوان، إلخ. كتابة برنامج يدعم كل هذه الطرفيات بشكل مباشر كان كابوساً.

لحل هذه المشكلة، ظهرت مكتبات تجريدية: Termcap (Terminal Capabilities) ولاحقاً Terminfo (Terminal Information). الفكرة هي أن يكون لديك قاعدة بيانات تصف قدرات كل طرفية، ويقوم برنامجك باستخدام مكتبة لقراءة هذه القدرات واستخدامها، بدلاً من ترميز تسلسلات الهروب بشكل ثابت.

الدوال `tgetent`, `tgetflag`, `tgetnum`, `tgetstr`, `tgoto`, `tputs` هي جزء من واجهة برمجة تطبيقات مكتبة Termcap (أو مكتبة متوافقة معها مثل ncurses التي توفر أيضاً Terminfo).

**ملاحظة:** تُعتبر Termcap أقدم وأبسط من Terminfo. معظم الأنظمة الحديثة تستخدم Terminfo، ولكنها غالباً ما توفر واجهة متوافقة مع Termcap من خلال مكتبة مثل ncurses. شرحنا سيركز على واجهة Termcap كما هي محددة، مع العلم أنها قد تُنفذ داخلياً باستخدام Terminfo.

---

**ما هي قاعدة بيانات Termcap/Terminfo؟**

*   **Termcap:** عادةً ملف نصي واحد يسمى `/etc/termcap`. كل سطر (أو عدة أسطر متصلة بـ `\` في النهاية) يصف نوع طرفية واحد. يتكون الوصف من أسماء للطرفية (مفصولة بـ `|`، الأول هو الاسم الأكثر شيوعاً)، متبوعة بسلسلة من "القدرات" (capabilities) مفصولة بنقطتين رأسيتين (`:`).
    مثال لمدخل `vt100` (مبسط جداً):
    ```
    vt100|dec vt100:cl=\E[H\E[J:cm=\E[%i%d;%dH:
    ```
    هنا:
    *   `vt100|dec vt100`: أسماء الطرفية.
    *   `cl=\E[H\E[J`: قدرة مسح الشاشة (`cl` for clear). `\E` يمثل حرف ESC (ASCII 27).
    *   `cm=\E[%i%d;%dH`: قدرة تحريك المؤشر (`cm` for cursor motion). `%i` يخبر `tgoto` بأن المعاملات التالية يجب أن تُزاد بواحد. `%d` يمثل موضعاً للمعامل الرقمي (الصف والعمود).

*   **Terminfo:** أكثر تنظيماً. بدلاً من ملف واحد كبير، هي عبارة عن شجرة من الأدلة (عادةً تحت `/usr/share/terminfo/` أو `/lib/terminfo/`). كل ملف في هذه الأدلة هو نسخة مترجمة (compiled) من وصف طرفية واحدة. يُنظم حسب الحرف الأول من اسم الطرفية (مثلاً, `/usr/share/terminfo/x/xterm`). هذا يجعل البحث أسرع.

**أنواع القدرات (Capabilities):**
هناك ثلاثة أنواع من القدرات:
1.  **Boolean (منطقية):** تشير إلى ما إذا كانت الطرفية تدعم ميزة معينة أم لا. ليس لها قيمة، مجرد وجود اسمها يعني "صحيح". مثال: `am` (auto right margin - المؤشر ينتقل تلقائياً للسطر التالي عند الوصول لنهاية السطر).
2.  **Numeric (رقمية):** تمثل قيمة رقمية. مثال: `co#80` (columns - عدد الأعمدة هو 80).
3.  **String (نصية):** تسلسل من الأحرف يجب إرساله إلى الطرفية لأداء وظيفة معينة. مثال: `cl=\E[H\E[J` (clear screen).

---

**8. الدالة `tgetent()` (Terminal Get Entry)**

*   **الغرض (Purpose):**
    تُستخدم الدالة `tgetent()` للبحث عن مدخل (entry) طرفية معينة في قاعدة بيانات Termcap وقراءته (تحميله) في مخزن مؤقت داخلي. هذه هي الخطوة الأولى قبل أن تتمكن من الاستعلام عن قدرات محددة باستخدام `tgetflag`, `tgetnum`, أو `tgetstr`.

*   **التضمين (Header File):**
    ```c
    #include <termcap.h> // أو <curses.h> و <term.h> إذا كنت تستخدم ncurses
    ```
    على بعض الأنظمة، قد تحتاج إلى ربط (link) برنامجك مع مكتبة Termcap أو ncurses (مثلاً, `gcc myprog.c -ltermcap` أو `gcc myprog.c -lncurses`).

*   **التصريح (Synopsis):**
    ```c
    int tgetent(char *bp, const char *name);
    ```

*   **المعاملات (Parameters):**
    *   `char *bp`: مؤشر إلى مخزن مؤقت (buffer) توفره أنت. يجب أن يكون هذا المخزن كبيراً بما يكفي لاحتواء مدخل Termcap للطرفية المطلوبة. حجم شائع وآمن نسبياً هو 1024 بايت (أو `TERMBUFSIZE` إذا كان مُعرّفاً). إذا تم تمرير `NULL` لـ `bp`، فقد تقوم بعض التطبيقات بتخصيص الذاكرة ديناميكياً (ولكن هذا غير مضمون أو قياسي). **ملاحظة:** سلوك `bp` يمكن أن يختلف. في تطبيقات ncurses التقليدية، `bp` قد لا يُستخدم إذا كانت ncurses تستخدم قاعدة بيانات Terminfo المترجمة، وفي هذه الحالة، `bp` هو مجرد بقايا تاريخية ويمكن أن يكون `NULL`. ومع ذلك، لتوفير `bp` لا يضر.
    *   `const char *name`: اسم نوع الطرفية الذي تبحث عنه (مثلاً, `"vt100"`, `"xterm"`). عادةً ما يتم الحصول على هذا الاسم من متغير البيئة `TERM` باستخدام `getenv("TERM")`.

*   **القيمة المُرجعة (Return Value):**
    *   `1`: إذا تم العثور على المدخل بنجاح وتم تحميله.
    *   `0`: إذا لم يتم العثور على مدخل بالاسم المحدد.
    *   `-1`: إذا لم يتم العثور على قاعدة بيانات Termcap (ملف `/etc/termcap` أو ما يعادله) أو لا يمكن الوصول إليها.
    *   `-2`: (خاص بـ ncurses) إذا كانت قاعدة بيانات Terminfo لا يمكن فتحها أو أنها تالفة.

*   **الشرح التفصيلي (Detailed Explanation):**
    1.  تأخذ `tgetent` الاسم `name`.
    2.  تبحث عن قاعدة بيانات Termcap. تقليدياً، هذا هو ملف `/etc/termcap`. إذا كان متغير البيئة `TERMCAP` معيناً:
        *   إذا كانت قيمته تبدأ بـ `/`، فإنه يُعتبر مساراً لملف Termcap.
        *   وإلا، تُعتبر قيمته هي مدخل Termcap نفسه مباشرة (يجب أن يكون `bp` كبيراً بما يكفي لنسخه).
    3.  إذا تم استخدام ملف Termcap، تبحث الدالة فيه عن سطر يبدأ بأحد أسماء `name`.
    4.  إذا تم العثور على المدخل، يتم نسخه (أو جزء منه، أو معلومات مشتقة منه) إلى مخزن مؤقت داخلي (أو قد تستخدم `bp` إذا كان التنفيذ يتطلب ذلك). الدوال اللاحقة (`tgetflag`, `tgetnum`, `tgetstr`) ستبحث في هذا المخزن المؤقت الداخلي.

    **ملاحظة حول `bp` مع ncurses:**
    إذا كانت مكتبة Curses/Termcap التي تستخدمها هي ncurses، وكان `name` يشير إلى طرفية موجودة في قاعدة بيانات Terminfo المترجمة، فإن ncurses ستقرأ من ملف Terminfo الثنائي. في هذه الحالة، المخزن المؤقت `bp` قد لا يُستخدم بشكل كبير، وقد يُستخدم فقط إذا كان متغير `TERMCAP` يشير إلى مدخل Termcap حرفي أو ملف. لتجنب الارتباك، من الآمن توفير `bp` صالح.

*   **أمثلة عملية (Use Cases/Examples):**

    ```c
    #include <stdio.h>
    #include <stdlib.h>    // For getenv(), exit()
    #include <termcap.h>   // For tgetent() and other tget* functions

    // بعض الأنظمة قد تحتاج إلى تعريف هذا إذا لم يكن موجوداً في termcap.h
    #ifndef TERMBUFSIZE
    #define TERMBUFSIZE 2048 // حجم آمن للمخزن المؤقت لـ termcap
    #endif

    char term_buffer[TERMBUFSIZE]; // مخزن مؤقت لـ tgetent

    int main() {
        char *term_name;
        int status;

        // 1. الحصول على نوع الطرفية من متغير البيئة TERM
        term_name = getenv("TERM");
        if (term_name == NULL) {
            fprintf(stderr, "Error: TERM environment variable not set.\n");
            fprintf(stderr, "Please set TERM to your terminal type (e.g., xterm, vt100).\n");
            return 1;
        }
        printf("Terminal type from TERM env: %s\n", term_name);

        // 2. تحميل مدخل Termcap للطرفية
        // نمرر term_buffer الخاص بنا.
        status = tgetent(term_buffer, term_name);

        if (status == 1) {
            printf("Successfully loaded termcap entry for '%s'.\n", term_name);
            printf("The (potentially used) term_buffer starts with: \"%.30s...\"\n", term_buffer);
            // الآن يمكننا استخدام tgetflag, tgetnum, tgetstr
            // (سيتم شرحها لاحقاً)
        } else if (status == 0) {
            fprintf(stderr, "Error: No termcap entry found for terminal type '%s'.\n", term_name);
            fprintf(stderr, "Check if '%s' is a valid terminal type and if termcap/terminfo database is correctly installed.\n", term_name);
            return 1;
        } else if (status == -1) {
            fprintf(stderr, "Error: Termcap database (e.g., /etc/termcap) could not be found or accessed.\n");
            return 1;
        } else if (status == -2) { // خاص بـ ncurses/terminfo
            fprintf(stderr, "Error: Terminfo database could not be opened or is corrupted.\n");
            return 1;
        } else {
            fprintf(stderr, "Error: tgetent failed with unknown status code %d for terminal type '%s'.\n", status, term_name);
            return 1;
        }

        // ... (الاستعلام عن القدرات هنا) ...

        return 0;
    }
    ```
    **لتجربة المثال:**
    1.  **احفظ الكود** باسم `load_termcap.c`.
    2.  **ترجمه مع الربط بمكتبة termcap أو ncurses:**
        *   `gcc load_termcap.c -o load_termcap -ltermcap` (إذا كانت termcap مستقلة)
        *   أو `gcc load_termcap.c -o load_termcap -lncurses` (الأكثر شيوعاً اليوم)
    3.  **شغله:** `./load_termcap`
        إذا كان `TERM` معيناً بشكل صحيح ونظام Termcap/Terminfo مثبت، يجب أن ترى رسالة نجاح.
    4.  **جرب مع اسم طرفية خاطئ:**
        `TERM=faketerminal ./load_termcap`
        سترى رسالة خطأ (status 0).

*   **اعتبارات هامة (Important Considerations):**
    *   **الربط (Linking):** لا تنس ربط برنامجك مع المكتبة المناسبة (`-ltermcap` أو `-lncurses`).
    *   **المخزن المؤقت `bp`:** على الرغم من أن ncurses قد لا تستخدمه دائماً، فمن التقليدي توفيره. تأكد من أنه كبير بما فيه الكفاية (1024 أو 2048 بايت).
    *   **`TERM`:** نجاح `tgetent` يعتمد كلياً على صحة متغير البيئة `TERM` ووجود مدخل مطابق في قاعدة البيانات.
    *   **التوافق:** `tgetent` هي جزء من واجهة Termcap القديمة. Terminfo هي الخلف الأكثر حداثة وقوة، ولكن ncurses توفر طبقة توافق جيدة لـ Termcap.

---

بعد استدعاء `tgetent` بنجاح، يمكننا الآن استخدام الدوال الأخرى للاستعلام عن القدرات المحددة.

---

**9. الدالة `tgetflag()` (Terminal Get Flag/Boolean Capability)**

*   **الغرض (Purpose):**
    تُستخدم `tgetflag()` للتحقق مما إذا كانت قدرة منطقية (boolean capability) معينة موجودة (معرّفة) في مدخل Termcap الذي تم تحميله بواسطة `tgetent()`. القدرات المنطقية لا تأخذ قيمة؛ مجرد وجود اسمها في مدخل Termcap يعني أنها "صحيحة" أو "مدعومة".

*   **التضمين (Header File):**
    ```c
    #include <termcap.h> // أو <curses.h> و <term.h>
    ```

*   **التصريح (Synopsis):**
    ```c
    int tgetflag(const char *id);
    ```

*   **المعاملات (Parameters):**
    *   `const char *id`: سلسلة نصية قصيرة (عادةً حرفين) تمثل كود القدرة المنطقية التي تبحث عنها (مثلاً, `"am"` لوجود هامش أيمن تلقائي، `"xn"` لوجود "newline glitch" حيث لا يمكن للمؤشر الكتابة في الزاوية اليمنى السفلية).

*   **القيمة المُرجعة (Return Value):**
    *   `1`: إذا كانت القدرة المنطقية `id` موجودة في مدخل Termcap الحالي.
    *   `0`: إذا لم تكن القدرة المنطقية `id` موجودة.
    *   (لا يوجد إشارة خطأ واضحة بخلاف 0 إذا لم تكن قد استدعيت `tgetent` بنجاح أولاً، لذا تأكد من نجاح `tgetent`).

*   **الشرح التفصيلي (Detailed Explanation):**
    بعد أن تقوم `tgetent()` بتحميل معلومات الطرفية، تبحث `tgetflag()` في هذه المعلومات عن الكود `id`. إذا وجدته، فهذا يعني أن الطرفية تدعم هذه الميزة.

    **أمثلة على أكواد قدرات منطقية شائعة (IDs):**
    *   `am`: (Auto Right Margin) الطرفية لديها هوامش تلقائية (المؤشر يلتف إلى السطر التالي عند الوصول إلى الحافة اليمنى).
    *   `xn`: (Newline Glitch / Eat Newline Glitch) المؤشر لا يمكنه الكتابة في الموضع الأخير من السطر الأخير، والانتقال إلى سطر جديد في هذا الموضع قد يسبب مشاكل.
    *   `hc`: (Hard Copy) الطرفية هي طابعة ورقية.
    *   `hs`: (Has Status Line) الطرفية لديها سطر حالة (status line).
    *   `km`: (Has Meta Key) الطرفية لديها مفتاح "Meta".
    *   `mi`: (Move Insert) آمن لتحريك المؤشر في وضع الإدراج (insert mode).
    *   `os`: (Overstrike) الطرفية يمكنها الطباعة فوق الأحرف (overstrike).
    *   `ul`: (Underline) الطرفية تدعم التسطير (underline) باستخدام تسلسل هروب خاص (مختلف عن الدخول والخروج من وضع التسطير).
    *   `eo`: (Can erase overstrikes with a blank) يمكن مسح الأحرف المطبوعة فوق بعضها عن طريق الكتابة فوقها بمسافة.

    يمكنك العثور على قائمة كاملة بأكواد قدرات Termcap/Terminfo في صفحة الدليل `terminfo(5)`.

*   **أمثلة عملية (Use Cases/Examples):**

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <termcap.h>

    #ifndef TERMBUFSIZE
    #define TERMBUFSIZE 2048
    #endif

    char term_buffer[TERMBUFSIZE];

    int main() {
        char *term_name = getenv("TERM");
        if (!term_name) {
            fprintf(stderr, "TERM not set.\n");
            return 1;
        }

        if (tgetent(term_buffer, term_name) != 1) {
            fprintf(stderr, "Could not load termcap entry for %s.\n", term_name);
            return 1;
        }
        printf("Termcap entry for %s loaded.\n", term_name);

        // التحقق من بعض القدرات المنطقية
        if (tgetflag("am")) { // Auto right margin
            printf("Terminal has auto right margin (am).\n");
        } else {
            printf("Terminal does NOT have auto right margin (am).\n");
        }

        if (tgetflag("xn")) { // Newline glitch
            printf("Terminal has newline glitch (xn).\n");
        } else {
            printf("Terminal does NOT have newline glitch (xn).\n");
        }
        
        if (tgetflag("hc")) { // Hard copy terminal
            printf("Terminal is a hardcopy device (hc).\n");
        } else {
            printf("Terminal is NOT a hardcopy device (hc).\n");
        }

        // قدرة غير موجودة (للاختبار)
        if (tgetflag("XY")) { // XY is likely not a real capability
            printf("Flag 'XY' is set (unexpected).\n");
        } else {
            printf("Flag 'XY' is NOT set (as expected).\n");
        }

        return 0;
    }
    ```
    **لتجربة المثال:**
    1.  **احفظ الكود** باسم `check_flags.c`.
    2.  **ترجمه:** `gcc check_flags.c -o check_flags -lncurses` (أو `-ltermcap`)
    3.  **شغله:** `./check_flags`
        سترى ما إذا كانت طرفيتك تدعم القدرات `am` و `xn`.

*   **اعتبارات هامة (Important Considerations):**
    *   **استدعاء `tgetent` أولاً:** يجب دائماً استدعاء `tgetent()` بنجاح قبل استخدام `tgetflag()`.
    *   **أكواد القدرات:** تأكد من استخدام الأكواد الصحيحة المكونة من حرفين (أو أحياناً أكثر للقدرات غير القياسية أو الموسعة) كما هي محددة في وثائق Termcap/Terminfo.

---

**10. الدالة `tgetnum()` (Terminal Get Numeric Capability)**

*   **الغرض (Purpose):**
    تُستخدم `tgetnum()` للحصول على قيمة قدرة رقمية (numeric capability) معينة من مدخل Termcap الذي تم تحميله. القدرات الرقمية تمثل قيماً مثل عدد الأعمدة، عدد الأسطر، عدد الألوان المتاحة، إلخ.

*   **التضمين (Header File):**
    ```c
    #include <termcap.h> // أو <curses.h> و <term.h>
    ```

*   **التصريح (Synopsis):**
    ```c
    int tgetnum(const char *id);
    ```

*   **المعاملات (Parameters):**
    *   `const char *id`: سلسلة نصية قصيرة (عادةً حرفين) تمثل كود القدرة الرقمية التي تبحث عنها (مثلاً, `"co"` لعدد الأعمدة، `"li"` لعدد الأسطر).

*   **القيمة المُرجعة (Return Value):**
    *   إذا تم العثور على القدرة الرقمية `id` وكانت قيمتها مُعرّفة، تُرجع الدالة تلك القيمة الرقمية (كعدد صحيح).
    *   إذا لم يتم العثور على القدرة `id`، أو إذا لم تكن قيمتها مُعرّفة بشكل صحيح، تُرجع الدالة `-1`. (بعض المصادر تقول `0` إذا لم تكن موجودة، و `-1` إذا كانت موجودة ولكن قيمتها `0`. السلوك الأكثر شيوعاً هو `-1` لعدم الوجود أو خطأ).
    *   **هام:** إذا كانت القيمة الرقمية للقدرة هي بالفعل `0` أو `-1` بشكل شرعي، فلا يمكنك التمييز بين "غير موجودة" و "موجودة وقيمتها 0 أو -1" فقط من القيمة المُرجعة. ومع ذلك، معظم القدرات الرقمية القياسية لها قيم موجبة.

*   **الشرح التفصيلي (Detailed Explanation):**
    بعد تحميل مدخل Termcap بواسطة `tgetent()`, تبحث `tgetnum()` عن تعريف للقدرة `id` بالصيغة `id#value` (مثلاً, `co#80`). إذا وجدته، تُرجع الجزء `value` كعدد صحيح.

    **أمثلة على أكواد قدرات رقمية شائعة (IDs):**
    *   `co`: (Columns) عدد الأعمدة في السطر (مثلاً, `co#80`).
    *   `li`: (Lines) عدد الأسطر في الشاشة (مثلاً, `li#24`).
    *   `Co`: (Colors) أقصى عدد من الألوان التي تدعمها الطرفية (مثلاً, `Co#8`).
    *   `pa`: (Max Pairs) أقصى عدد من أزواج الألوان التي يمكن تعريفها (مثلاً, `pa#64`).
    *   `it`: (Init Tabs) عرض التاب الافتراضي (مثلاً, `it#8`).
    *   `sg`: (Standout Glitch) عدد المسافات الإضافية التي تشغلها سمة "standout" (مثل العكسي). إذا كانت `-1` أو غير موجودة، فهذا يعني أن "standout" لا يستهلك مساحة إضافية.
    *   `pb`: (Padding Baud Rate) أقل سرعة اتصال تتطلب إرسال حشو (padding).

*   **أمثلة عملية (Use Cases/Examples):**

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <termcap.h>

    #ifndef TERMBUFSIZE
    #define TERMBUFSIZE 2048
    #endif

    char term_buffer[TERMBUFSIZE];

    int main() {
        char *term_name = getenv("TERM");
        int columns, lines, colors;

        if (!term_name) {
            fprintf(stderr, "TERM not set.\n");
            return 1;
        }

        if (tgetent(term_buffer, term_name) != 1) {
            fprintf(stderr, "Could not load termcap entry for %s.\n", term_name);
            return 1;
        }
        printf("Termcap entry for %s loaded.\n", term_name);

        // الحصول على عدد الأعمدة
        columns = tgetnum("co");
        if (columns != -1) {
            printf("Number of columns (co): %d\n", columns);
        } else {
            printf("Number of columns (co) not defined or invalid.\n");
            // قد ترغب في استخدام قيمة افتراضية مثل 80
            // أو الحصول عليها من TIOCGWINSZ ioctl كبديل أكثر موثوقية
        }

        // الحصول على عدد الأسطر
        lines = tgetnum("li");
        if (lines != -1) {
            printf("Number of lines (li): %d\n", lines);
        } else {
            printf("Number of lines (li) not defined or invalid.\n");
            // قد ترغب في استخدام قيمة افتراضية مثل 24
            // أو الحصول عليها من TIOCGWINSZ ioctl
        }

        // الحصول على عدد الألوان
        colors = tgetnum("Co"); // 'Co' للألوان، وليس 'co'
        if (colors != -1) {
            printf("Number of colors (Co): %d\n", colors);
        } else {
            printf("Number of colors (Co) not defined (terminal might be monochrome or uses default).\n");
        }
        
        // قدرة غير موجودة (للاختبار)
        int bogus_num = tgetnum("ZZ");
        if (bogus_num == -1) {
            printf("Numeric capability 'ZZ' not found (as expected).\n");
        } else {
            printf("Numeric capability 'ZZ' found with value %d (unexpected).\n", bogus_num);
        }


        return 0;
    }
    ```
    **لتجربة المثال:**
    1.  **احفظ الكود** باسم `check_nums.c`.
    2.  **ترجمه:** `gcc check_nums.c -o check_nums -lncurses` (أو `-ltermcap`)
    3.  **شغله:** `./check_nums`
        سترى عدد الأعمدة والأسطر والألوان (إذا كانت مُعرّفة) لطرفيتك.

*   **اعتبارات هامة (Important Considerations):**
    *   **`tgetent` أولاً:** كالعادة، `tgetent()` يجب أن تُستدعى بنجاح.
    *   **القيمة المُرجعة `-1`:** تذكر أنها قد تعني "غير موجودة" أو "موجودة وقيمتها -1". للسعات مثل `co` و `li`، القيمة `-1` تعني عادةً أنها غير مُعرّفة في Termcap.
    *   **البديل لـ `co` و `li`:** للحصول على أبعاد النافذة (الأعمدة والأسطر)، يُعتبر استخدام `ioctl(fd, TIOCGWINSZ, &winsize_struct)` أكثر موثوقية وديناميكية من `tgetnum("co")` و `tgetnum("li")`، لأن `ioctl` يعكس الحجم الفعلي للنافذة الذي قد يتغير، بينما قيم Termcap ثابتة للنوع. ومع ذلك، يمكن استخدام قيم Termcap كقيم احتياطية إذا فشل `ioctl`.
    *   **التحقق من الأكواد:** استخدم أكواد القدرات الصحيحة من وثائق Terminfo.

---

**11. الدالة `tgetstr()` (Terminal Get String Capability)**

*   **الغرض (Purpose):**
    تُستخدم `tgetstr()` للحصول على قيمة قدرة نصية (string capability) معينة من مدخل Termcap الذي تم تحميله. القدرات النصية هي تسلسلات من الأحرف (غالباً تسلسلات هروب ANSI) التي، عند إرسالها إلى الطرفية، تؤدي إلى إجراء معين مثل مسح الشاشة، تحريك المؤشر، تغيير الألوان، إلخ.

*   **التضمين (Header File):**
    ```c
    #include <termcap.h> // أو <curses.h> و <term.h>
    ```

*   **التصريح (Synopsis):**
    ```c
    char *tgetstr(const char *id, char **area);
    ```

*   **المعاملات (Parameters):**
    *   `const char *id`: سلسلة نصية قصيرة (عادةً حرفين) تمثل كود القدرة النصية التي تبحث عنها (مثلاً, `"cl"` لمسح الشاشة، `"cm"` لتحريك المؤشر).
    *   `char **area`: مؤشر إلى مؤشر إلى حرف (`char **`). هذا هو المكان الذي ستنسخ فيه `tgetstr` السلسلة النصية للقدرة.
        *   يجب أن يشير `*area` (أي القيمة التي يشير إليها `area`) إلى منطقة ذاكرة كافية (مخزن مؤقت) قدمتها أنت.
        *   بعد نسخ السلسلة، ستقوم `tgetstr` بتحديث `*area` ليشير إلى الموقع التالي المتاح في مخزنك المؤقت (أي بعد نهاية السلسلة المنسوخة). هذا يسمح لك باستدعاء `tgetstr` عدة مرات متتالية لملء مخزن مؤقت واحد بقدرات متعددة.
        *   إذا مررت `NULL` لـ `area` (أو لـ `*area`)، فإن بعض التطبيقات القديمة قد تستخدم مخزناً مؤقتاً ثابتاً داخلياً (وهو أمر غير آمن للخيوط ويجب تجنبه). **ncurses (والتطبيقات الحديثة) تتطلب منك إدارة الذاكرة بنفسك: إما أن توفر مخزناً مؤقتاً عبر `area`، أو إذا كان `area` أو `*area` هو `NULL`، فقد تُرجع ncurses مؤشراً إلى سلسلة في منطقة ثابتة خاصة بها (والتي يمكن أن تُكتب فوقها لاحقاً). الطريقة الآمنة هي توفير مخزنك المؤقت الخاص.**

*   **القيمة المُرجعة (Return Value):**
    *   إذا تم العثور على القدرة النصية `id`، تُرجع الدالة مؤشراً إلى السلسلة النصية للقدرة (null-terminated string). هذه السلسلة ستكون قد نُسخت إلى المخزن المؤقت الذي قدمته عبر `area` (إذا كان `area` و `*area` صالحين).
    *   إذا لم يتم العثور على القدرة `id`، أو إذا لم تكن قيمتها مُعرّفة، تُرجع الدالة `NULL`.
    *   إذا كان المخزن المؤقت الذي قدمته عبر `area` صغيراً جداً، فقد يكون السلوك غير محدد (قد تُرجع `NULL` أو تكتب خارج الحدود).

*   **الشرح التفصيلي (Detailed Explanation):**
    بعد `tgetent()`, تبحث `tgetstr()` عن تعريف للقدرة `id` بالصيغة `id=string_value` (مثلاً, `cl=\E[H\E[J`).
    إذا وجدته:
    1.  تُنسخ `string_value` إلى الموقع الذي يشير إليه `*area`.
    2.  يتم إنهاء السلسلة المنسوخة بحرف `\0`.
    3.  يتم تحديث `*area` ليشير إلى البايت التالي بعد `\0` في مخزنك المؤقت.
    4.  تُرجع الدالة المؤشر الأصلي حيث بدأت السلسلة (أي القيمة الأصلية لـ `*area` قبل التحديث).

    **إدارة المخزن المؤقت `area`:**
    ```c
    char capabilities_buffer[1024]; // مخزن مؤقت كبير كفاية
    char *buffer_ptr = capabilities_buffer; // مؤشر متحرك داخل المخزن

    // ... tgetent(...) ...

    char *cl_str = tgetstr("cl", &buffer_ptr); // cl_str يشير إلى بداية "cl" في capabilities_buffer
                                            // buffer_ptr الآن يشير إلى ما بعد "cl"
    char *cm_str = tgetstr("cm", &buffer_ptr); // cm_str يشير إلى بداية "cm" في capabilities_buffer
                                            // buffer_ptr الآن يشير إلى ما بعد "cm"
    // وهكذا...
    ```
    يجب التأكد من أن `capabilities_buffer` كبير بما يكفي لجميع السلاسل التي تريد استخراجها.

    **أمثلة على أكواد قدرات نصية شائعة (IDs):**
    *   `cl`: (Clear Screen) مسح الشاشة بأكملها وتحريك المؤشر إلى أعلى اليسار.
    *   `cm`: (Cursor Motion) تحريك المؤشر إلى صف وعمود معينين. هذه السلسلة عادةً ما تحتوي على رموز تنسيق للمعلمات (مثل `%d`, `%i`) التي يجب معالجتها بواسطة `tgoto()`.
    *   `ce`: (Clear to End of Line) مسح من المؤشر حتى نهاية السطر.
    *   `cd`: (Clear to End of Display) مسح من المؤشر حتى نهاية الشاشة.
    *   `so`: (Enter Standout Mode) بدء وضع التمييز (مثل العكسي أو الغامق).
    *   `se`: (Exit Standout Mode) إنهاء وضع التمييز.
    *   `us`: (Enter Underline Mode) بدء وضع التسطير.
    *   `ue`: (Exit Underline Mode) إنهاء وضع التسطير.
    *   `md`: (Enter Bold Mode) بدء وضع الغامق.
    *   `mr`: (Enter Reverse Video Mode) بدء وضع الفيديو العكسي.
    *   `mb`: (Enter Blinking Mode) بدء وضع الوميض.
    *   `me`: (Exit All Attribute Modes) إنهاء جميع أوضاع السمات (standout, underline, bold, etc.) والعودة إلى الوضع الطبيعي.
    *   `ku`: (Key Up Arrow) السلسلة التي تُرسل عند الضغط على السهم العلوي.
    *   `kd`: (Key Down Arrow) السلسلة للسهم السفلي.
    *   `kl`: (Key Left Arrow) السلسلة للسهم الأيسر.
    *   `kr`: (Key Right Arrow) السلسلة للسهم الأيمن.
    *   `ho`: (Home Cursor) تحريك المؤشر إلى الزاوية العلوية اليسرى (الصف 0, العمود 0).
    *   `vb`: (Visible Bell) إصدار "جرس مرئي" (مثل وميض الشاشة) بدلاً من صوت.
    *   `cr`: (Carriage Return) تسلسل لإرجاع المؤشر لبداية السطر الحالي (عادةً `\r`).
    *   `nl`: (Newline) تسلسل للانتقال لسطر جديد (عادةً `\n`).
    *   `ta`: (Tab) تسلسل للتاب (عادةً `\t`).
    *   `bl`: (Bell) تسلسل لإصدار صوت الجرس (عادةً `\a`).

    **تنسيق المعلمات في السلاسل (مثل `cm`):**
    بعض القدرات النصية، مثل `cm` (تحريك المؤشر)، تتطلب معلمات (مثل رقم الصف ورقم العمود). تحتوي السلسلة المُرجعة من `tgetstr()` لهذه القدرات على أكواد تنسيق خاصة:
    *   `%d`: مكان لمعامل رقمي.
    *   `%2`: مكان لمعامل رقمي، مطبوع بعرض حقل 2 على الأقل، مع حشو بالمسافات.
    *   `%3`: ... عرض حقل 3 ...
    *   `%.`: مكان لمعامل حرفي.
    *   `%+c`: مكان لمعامل رقمي، يُضاف إليه قيمة الحرف `c` ثم يُطبع كحرف.
    *   `%i`: يُعلم `tgoto()` (التي سنتحدث عنها تالياً) بأن المعاملات الرقمية التالية (الصف والعمود) مُعطاة على أساس 0، ويجب زيادتها بواحد قبل التنسيق (لأن العديد من الطرفيات تتوقع ترقيماً يبدأ من 1).
    *   `%%`: لطباعة علامة `%` حرفياً.
    *   `%r`: (في بعض التطبيقات) تبديل ترتيب المعاملين (صف، عمود) إلى (عمود، صف).
    *   `%>xy`: إذا كان المعامل أكبر من `x`، أضف `y` إليه.

    الدالة `tgoto()` هي المسؤولة عن أخذ هذه السلسلة الخام وتطبيق المعلمات عليها.

*   **أمثلة عملية (Use Cases/Examples):**

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <termcap.h>
    #include <string.h> // For strlen (to check buffer space)

    #ifndef TERMBUFSIZE
    #define TERMBUFSIZE 2048
    #endif

    char term_buffer[TERMBUFSIZE];        // لـ tgetent
    char capabilities_area[TERMBUFSIZE]; // لتخزين السلاسل من tgetstr

    // دالة مساعدة لطباعة سلسلة مع إظهار الأحرف غير القابلة للطباعة
    void print_escaped_string(const char *label, const char *str) {
        if (!str) {
            printf("%s: (null)\n", label);
            return;
        }
        printf("%s: \"", label);
        for (const char *p = str; *p; ++p) {
            if (*p == '\E') { // ESC (ASCII 27)
                printf("\\E");
            } else if (*p == '\n') {
                printf("\\n");
            } else if (*p == '\r') {
                printf("\\r");
            } else if (*p == '\t') {
                printf("\\t");
            } else if (*p >= 32 && *p <= 126) { // قابل للطباعة
                putchar(*p);
            } else { // غير قابل للطباعة
                printf("\\x%02X", (unsigned char)*p);
            }
        }
        printf("\"\n");
    }


    int main() {
        char *term_name = getenv("TERM");
        char *buffer_ptr = capabilities_area; // مؤشر متحرك لمنطقة القدرات
        char *cl_str, *cm_str, *so_str, *se_str;

        if (!term_name) {
            fprintf(stderr, "TERM not set.\n");
            return 1;
        }

        if (tgetent(term_buffer, term_name) != 1) {
            fprintf(stderr, "Could not load termcap entry for %s.\n", term_name);
            return 1;
        }
        printf("Termcap entry for %s loaded.\n", term_name);

        // الحصول على سلسلة مسح الشاشة (cl)
        cl_str = tgetstr("cl", &buffer_ptr);
        if (cl_str) {
            print_escaped_string("Clear screen (cl)", cl_str);
            // تأكد أن لدينا مساحة كافية متبقية قبل الاستدعاء التالي
            // (capabilities_area + TERMBUFSIZE) - buffer_ptr  هو المساحة المتبقية
            if ((capabilities_area + TERMBUFSIZE) - buffer_ptr < 100) { // تحقق تقديري
                 fprintf(stderr, "Warning: Low space in capabilities_area for next string.\n");
            }
        } else {
            printf("Clear screen (cl) capability not found.\n");
        }

        // الحصول على سلسلة تحريك المؤشر (cm)
        // لاحظ أن هذه السلسلة ستحتوي على رموز تنسيق
        cm_str = tgetstr("cm", &buffer_ptr);
        if (cm_str) {
            print_escaped_string("Cursor motion (cm)", cm_str);
        } else {
            printf("Cursor motion (cm) capability not found.\n");
        }

        // الحصول على سلسلة الدخول لوضع التمييز (so)
        so_str = tgetstr("so", &buffer_ptr);
        if (so_str) {
            print_escaped_string("Enter standout mode (so)", so_str);
        } else {
            printf("Enter standout mode (so) capability not found.\n");
        }

        // الحصول على سلسلة الخروج من وضع التمييز (se)
        se_str = tgetstr("se", &buffer_ptr);
        if (se_str) {
            print_escaped_string("Exit standout mode (se)", se_str);
        } else {
            printf("Exit standout mode (se) capability not found.\n");
        }
        
        // مثال لقدرة قد لا تكون موجودة
        char *xx_str = tgetstr("xx", &buffer_ptr); // "xx" عادةً غير موجودة
        if (xx_str) {
            print_escaped_string("Bogus capability (xx)", xx_str);
        } else {
            printf("Bogus capability (xx) not found (as expected).\n");
        }


        // كيف تستخدم هذه السلاسل؟ عادةً مع tputs()
        // مثال: مسح الشاشة (إذا كانت cl_str موجودة)
        // if (cl_str) {
        //    tputs(cl_str, 1, putchar); // سيتم شرح tputs لاحقاً
        //    fflush(stdout);
        // }

        return 0;
    }
    ```
    **لتجربة المثال:**
    1.  **احفظ الكود** باسم `check_strings.c`.
    2.  **ترجمه:** `gcc check_strings.c -o check_strings -lncurses` (أو `-ltermcap`)
    3.  **شغله:** `./check_strings`
        سترى تسلسلات الهروب لطرفيتك (إذا كانت مُعرّفة).

*   **اعتبارات هامة (Important Considerations):**
    *   **`tgetent` أولاً.**
    *   **إدارة الذاكرة لـ `area`:** هذه هي النقطة الأكثر تعقيداً في `tgetstr`. يجب أن توفر مخزناً مؤقتاً كافياً وتمرر مؤشراً إلى مؤشر (`char **`) إليه. سيتم تحديث مؤشرك الداخلي.
    *   **`NULL` المُرجعة:** إذا أرجعت `tgetstr` القيمة `NULL`، فهذا يعني أن القدرة غير موجودة أو أن هناك مشكلة (مثل عدم كفاية المخزن المؤقت في بعض التطبيقات القديمة، على الرغم من أن السلوك القياسي هو فقط لعدم الوجود).
    *   **سلاسل خام:** السلاسل المُرجعة (مثل تلك لـ `cm`) قد تحتاج إلى مزيد من المعالجة بواسطة `tgoto()` قبل أن تتمكن من استخدامها مباشرة مع `tputs()`.
    *   **الحشو (Padding):** بعض السلاسل قد تحتوي على معلومات حشو (مثل `$<5>`) تشير إلى تأخيرات مطلوبة. الدالة `tputs()` تتعامل مع هذا.

---

**12. الدالة `tgoto()` (Terminal Go To / Format Cursor Motion String)**

*   **الغرض (Purpose):**
    تُستخدم `tgoto()` لتنسيق سلسلة قدرة تحريك المؤشر (عادةً السلسلة التي تم الحصول عليها بواسطة `tgetstr("cm", ...)`). هي تأخذ سلسلة `cm` الخام، ورقم العمود والصف المطلوبين، وتُرجع سلسلة نصية جديدة جاهزة للإرسال إلى الطرفية (عبر `tputs()`) لتحريك المؤشر إلى هذا الموقع.

*   **التضمين (Header File):**
    ```c
    #include <termcap.h> // أو <curses.h> و <term.h>
    ```

*   **التصريح (Synopsis):**
    ```c
    char *tgoto(const char *cap, int col, int row);
    ```

*   **المعاملات (Parameters):**
    *   `const char *cap`: السلسلة النصية الخام لقدرة تحريك المؤشر، كما تم الحصول عليها من `tgetstr("cm", ...)`.
    *   `int col`: رقم العمود الوجهة (يبدأ من 0).
    *   `int row`: رقم الصف الوجهة (يبدأ من 0).

*   **القيمة المُرجعة (Return Value):**
    *   تُرجع مؤشراً إلى سلسلة نصية مُنسّقة (موجودة في مخزن مؤقت ثابت داخلي). هذه السلسلة تحتوي على تسلسل الهروب الفعلي لتحريك المؤشر إلى `(col, row)`.
    *   إذا كانت `cap` غير صالحة أو حدث خطأ، قد تُرجع مؤشراً إلى سلسلة تحتوي على رسالة خطأ (مثل "OOPS") أو سلوك غير محدد. يجب عدم الاعتماد على القيمة المُرجعة للتحقق من الخطأ بشكل كامل؛ من الأفضل التأكد من أن `cap` هي سلسلة `cm` صالحة أولاً.
    *   **هام جداً:** السلسلة المُرجعة موجودة في **مخزن مؤقت ثابت (static buffer)** يتم الكتابة فوقه في كل استدعاء لـ `tgoto()`. إذا كنت بحاجة إلى الاحتفاظ بالسلسلة، يجب نسخها فوراً.

*   **الشرح التفصيلي (Detailed Explanation):**
    تعمل `tgoto()` كالتالي:
    1.  تحلل سلسلة `cap` بحثاً عن أكواد التنسيق (`%d`, `%i`, `%.`, `%+c`, إلخ).
    2.  تستبدل هذه الأكواد بالقيم `col` و `row` المقدمة.
    3.  إذا كان هناك كود `%i` في `cap`، فإنها تزيد `col` و `row` بواحد قبل استخدامها (لأن `tgoto` تتوقع إحداثيات تبدأ من 0، ولكن العديد من تسلسلات `cm` للطرفيات تتوقع إحداثيات تبدأ من 1).
    4.  تضع السلسلة الناتجة في مخزنها المؤقت الثابت وتُرجع مؤشراً إليه.

    **مثال:**
    *   لنفترض أن `tgetstr("cm", ...)` أرجعت `\E[%i%d;%dH` لـ `cap`.
    *   إذا استدعيت `tgoto(cap, 5, 10)`:
        *   بسبب `%i`، سيتم استخدام `col = 5+1=6` و `row = 10+1=11`.
        *   سيتم استبدال `%d` الأول بـ `11` (الصف عادةً يأتي أولاً في تسلسلات ANSI).
        *   سيتم استبدال `%d` الثاني بـ `6`.
        *   السلسلة المُرجعة ستكون شيئاً مثل `\E[11;6H`.

    **ترتيب المعاملات (Row/Column Order):**
    تقليدياً، معظم تسلسلات `cm` تتوقع (الصف، ثم العمود). `tgoto` أيضاً تتوقع أن المعاملات في سلسلة `cap` تظهر بهذا الترتيب (الصف ثم العمود). ومع ذلك، فإن `tgoto` نفسها تأخذ معاملاتها بالترتيب (العمود، ثم الصف): `tgoto(cap, column, row)`. هذا هو أحد مصادر الالتباس الشائعة.
    *   `tgoto(cm_string, desired_column, desired_row)`
    *   القيم `desired_column` و `desired_row` ستُستخدم لملء مواضع الصف والعمود في `cm_string` كما هي محددة هناك (عادةً الصف أولاً).

*   **أمثلة عملية (Use Cases/Examples):**

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <termcap.h>
    #include <string.h> // For strdup, if needed

    #ifndef TERMBUFSIZE
    #define TERMBUFSIZE 2048
    #endif

    char term_buffer[TERMBUFSIZE];
    char capabilities_area[TERMBUFSIZE];

    // (دالة print_escaped_string من المثال السابق)
    void print_escaped_string(const char *label, const char *str) {
        if (!str) { printf("%s: (null)\n", label); return; }
        printf("%s: \"", label);
        for (const char *p = str; *p; ++p) {
            if (*p == '\E') printf("\\E");
            else if (*p >= 32 && *p <= 126) putchar(*p);
            else printf("\\x%02X", (unsigned char)*p);
        }
        printf("\"\n");
    }


    int main() {
        char *term_name = getenv("TERM");
        char *buffer_ptr = capabilities_area;
        char *cm_raw_str;
        char *goto_str;

        if (!term_name) {
            fprintf(stderr, "TERM not set.\n");
            return 1;
        }

        if (tgetent(term_buffer, term_name) != 1) {
            fprintf(stderr, "Could not load termcap entry for %s.\n", term_name);
            return 1;
        }

        cm_raw_str = tgetstr("cm", &buffer_ptr);
        if (!cm_raw_str) {
            fprintf(stderr, "Cursor motion (cm) capability not found for %s.\n", term_name);
            return 1;
        }
        print_escaped_string("Raw 'cm' string", cm_raw_str);

        // تحريك المؤشر إلى العمود 10، الصف 5 (تذكر أن الإحداثيات تبدأ من 0)
        int target_col = 10;
        int target_row = 5;
        
        goto_str = tgoto(cm_raw_str, target_col, target_row);
        // cm_raw_str هو سلسلة القدرة لـ "cm"
        // target_col هو X (العمود)
        // target_row هو Y (الصف)
        
        // السلسلة المُرجعة من tgoto موجودة في مخزن مؤقت ثابت.
        // إذا أردت الاحتفاظ بها، انسخها.
        // char *saved_goto_str = strdup(goto_str);

        print_escaped_string("Formatted 'cm' for (col 10, row 5)", goto_str);
        printf("Note: 'tgoto' expects (capability, column, row).\n");
        printf("      The 'cm' string itself usually encodes (row, column).\n");

        // كيف تستخدمها:
        // tputs(goto_str, 1, putchar_function);
        // fflush(stdout);
        // (لتحريك المؤشر فعلياً، متبوعاً بطباعة شيء ما)

        // مثال آخر، إلى (0,0)
        char* home_str = tgoto(cm_raw_str, 0, 0);
        print_escaped_string("Formatted 'cm' for (col 0, row 0)", home_str);
        // لاحظ أن home_str الآن يشير إلى نفس المخزن المؤقت الثابت الذي كان يشير إليه goto_str،
        // لذا قيمة goto_str الأصلية قد تم الكتابة فوقها.
        // print_escaped_string("Value of previous goto_str (likely overwritten)", goto_str);
        // هذا يوضح أهمية نسخ السلسلة إذا كنت بحاجة إليها لاحقاً.


        // if (saved_goto_str) free(saved_goto_str);
        return 0;
    }
    ```
    **لتجربة المثال:**
    1.  **احفظ الكود** باسم `format_cm.c`.
    2.  **ترجمه:** `gcc format_cm.c -o format_cm -lncurses` (أو `-ltermcap`)
    3.  **شغله:** `./format_cm`
        سترى سلسلة `cm` الخام، ثم النسخة المنسقة لتحريك المؤشر.

*   **اعتبارات هامة (Important Considerations):**
    *   **المخزن المؤقت الثابت:** هذه هي أكبر مشكلة في `tgoto()`. السلسلة المُرجعة مؤقتة جداً. إذا استدعيت `tgoto()` مرة أخرى، أو دوال أخرى تستخدم مخازن مؤقتة ثابتة مشابهة، فقد تُفقد القيمة.
    *   **ترتيب المعاملات:** تذكر الالتباس المحتمل: `tgoto(cap, COL, ROW)`، ولكن تسلسل `cap` (`cm`) نفسه عادةً ما يضع الصف قبل العمود. `%i` يعتني بتحويل الإحداثيات من 0-based إلى 1-based إذا لزم الأمر.
    *   **الصحة:** `tgoto` لا تقوم بالكثير من التحقق من صحة `cap`. إذا مررت سلسلة خاطئة، قد تحصل على نتائج غريبة.
    *   **البديل في ncurses:** في ncurses، الدالة `mvcur()` أو `tparm()` (التي تُستخدم داخلياً بواسطة `tgoto` في ncurses) توفر وظائف مشابهة وأكثر قوة. `tparm` هي الأقرب لـ `tgoto` ولكنها أكثر مرونة (يمكنها تنسيق أي قدرة نصية ذات معلمات، وليس فقط `cm`).

---

**13. الدالة `tputs()` (Terminal Put String / Output Capability String)**

*   **الغرض (Purpose):**
    تُستخدم `tputs()` لإخراج (طباعة) سلسلة قدرة طرفية (تم الحصول عليها من `tgetstr()` أو تم تنسيقها بواسطة `tgoto()`) إلى الطرفية. هي ليست مجرد `printf`. `tputs()` تقوم بأمرين مهمين إضافيين:
    1.  **تفسير معلومات الحشو (Padding):** بعض الطرفيات القديمة كانت بطيئة، وكانت تتطلب تأخيرات (فترات توقف قصيرة) بعد إرسال تسلسلات تحكم معينة حتى يتمكن الجهاز من معالجتها. هذه التأخيرات تُحدد في Termcap كـ "معلومات حشو"، مثل `$<5>` (انتظر 5 مللي ثانية). `tputs()` تقرأ هذه المعلومات وترسل العدد المناسب من "أحرف الحشو" (padding characters) أو تستدعي دالة تأخير مناسبة.
    2.  **استخدام دالة إخراج مُقدمة من المستخدم:** بدلاً من الكتابة مباشرة إلى `stdout`، تأخذ `tputs()` مؤشراً إلى دالة (مثل `putchar` أو دالة مخصصة) لاستخدامها في إخراج كل حرف من السلسلة (وأي أحرف حشو).

*   **التضمين (Header File):**
    ```c
    #include <termcap.h> // أو <curses.h> و <term.h>
    ```

*   **التصريح (Synopsis):**
    ```c
    int tputs(const char *str, int affcnt, int (*putc_func)(int));
    ```

*   **المعاملات (Parameters):**
    *   `const char *str`: السلسلة النصية للقدرة التي تريد إخراجها (مثلاً, `cl_str` من `tgetstr("cl",...)` أو `goto_str` من `tgoto(...)`).
    *   `int affcnt`: (Affected line count) عدد الأسطر المتأثرة بالعملية. هذا يُستخدم بواسطة `tputs` لحساب مقدار الحشو المطلوب، خاصة للعمليات التي تؤثر على أسطر متعددة (مثل مسح جزء من الشاشة). بالنسبة للعمليات التي تؤثر على سطر واحد أو المؤشر فقط، عادةً ما يكون هذا `1`.
    *   `int (*putc_func)(int)`: مؤشر إلى دالة ستستخدمها `tputs` لإخراج كل حرف. يجب أن تأخذ هذه الدالة وسيطاً من نوع `int` (يمثل الحرف) وتُرجع `int`. الدالة `putchar` القياسية (المُعرّفة في `stdio.h`) هي خيار شائع هنا.
        *   `int my_putchar_wrapper(int c) { return putchar(c); }`

*   **القيمة المُرجعة (Return Value):**
    *   تُرجع `0` عند النجاح.
    *   تُرجع `-1` عند الفشل (على الرغم من أن هذا نادر، وقد يعتمد على ما إذا كانت `putc_func` نفسها يمكن أن تفشل وتشير إلى ذلك بطريقة ما يمكن لـ `tputs` اكتشافها). الفشل الأكثر احتمالاً هو إذا كانت `str` هي `NULL`.

*   **الشرح التفصيلي (Detailed Explanation):**
    1.  تتكرر `tputs` عبر السلسلة `str`.
    2.  إذا واجهت معلومات حشو (مثل `$<delay_ms>`)، فإنها تحسب التأخير المطلوب بناءً على `delay_ms`، و `affcnt`، وسرعة الطرفية الحالية (التي تحصل عليها داخلياً، عادةً من متغيرات عامة مثل `ospeed` التي يتم تعيينها بواسطة `tgetent` أو من `struct termios`). ثم تقوم بإخراج العدد المناسب من أحرف الحشو (عادةً `NUL` ما لم يتم تعيين قدرة `pc` - padding character) أو تستدعي دالة تأخير.
    3.  لأي حرف آخر في `str`، تستدعي `putc_func(character)`.

    **الحشو (Padding):**
    *   كان الحشو مهماً جداً للطرفيات التسلسلية البطيئة. بالنسبة للطرفيات الحديثة السريعة (مثل محاكيات الطرفيات في البيئات الرسومية أو SSH)، عادةً ما يكون الحشو غير ضروري أو يتم تحسينه بعيداً (قد يتم ضبط سرعة الطرفية على قيمة عالية جداً بحيث يكون وقت الحشو المحسوب صفراً).
    *   يتم تحديد سرعة الطرفية (التي تؤثر على حسابات الحشو) بواسطة متغير عام خارجي يسمى `ospeed` (نوعه `short`) في تطبيقات Termcap التقليدية. يجب أن يتم تعيين هذا المتغير إلى قيمة مناسبة (عادةً من `cfgetospeed()` من `struct termios`) قبل استدعاء `tputs` إذا كنت تريد حشواً دقيقاً. ومع ذلك، فإن تطبيقات ncurses لـ `tputs` غالباً ما تهتم بهذا داخلياً بشكل أفضل.
    *   `BC` و `UP` هما متغيران عامان آخران (`char *`) قد تستخدمهما `tputs` لإرسال تسلسل الرجوع للخلف (`BC` من قدرة `bc`) أو الانتقال لسطر للأعلى (`UP` من قدرة `up`) إذا كانت `putc_func` هي `putchar` ولم تكن الطرفية في وضع مناسب. هذه تفاصيل تنفيذية قديمة.

    **`putc_func`:**
    السبب في وجود `putc_func` هو المرونة. قد ترغب في:
    *   الكتابة إلى `stdout` (باستخدام `putchar`).
    *   الكتابة إلى `stderr`.
    *   الكتابة إلى مخزن مؤقت في الذاكرة.
    *   الكتابة إلى ملف.
    *   إجراء معالجة إضافية لكل حرف قبل إخراجه.

    **متى تستخدم `affcnt`؟**
    *   `tputs(clear_screen_str, lines_on_screen, my_putc)`: عند مسح الشاشة، قد تؤثر على جميع الأسطر.
    *   `tputs(clear_to_end_of_line_str, 1, my_putc)`: مسح نهاية السطر يؤثر على سطر واحد.
    *   `tputs(cursor_motion_str, 1, my_putc)`: تحريك المؤشر يؤثر على سطر واحد (أو لا شيء إذا كان الحشو يعتمد فقط على الوقت).
    *   `tputs(delete_line_str, 1, my_putc)`: حذف سطر واحد.
    *   `tputs(insert_line_str, 1, my_putc)`: إدراج سطر واحد.
    *   بالنسبة للعديد من القدرات التي لا تتضمن مسحاً واسع النطاق أو إدراج/حذف أسطر متعددة، فإن `affcnt = 1` هو قيمة آمنة.

*   **أمثلة عملية (Use Cases/Examples):**

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <termcap.h>
    #include <unistd.h>    // For isatty, STDOUT_FILENO
    #include <termios.h>   // For tcgetattr and ospeed setting (optional but good practice)

    #ifndef TERMBUFSIZE
    #define TERMBUFSIZE 2048
    #endif

    char term_buffer[TERMBUFSIZE];
    char capabilities_area[TERMBUFSIZE];

    // متغيرات عامة تستخدمها مكتبة termcap (خاصة للـ padding)
    // قد تحتاج ncurses لتعريفها إذا لم تكن مدمجة.
    // extern short ospeed; // Output speed for padding calculations
    // extern char PC;      // Padding character (if defined by 'pc' capability)

    // دالة بسيطة لتغليف putchar
    int my_putchar_wrapper(int c) {
        return putchar(c);
    }

    int main() {
        char *term_name = getenv("TERM");
        char *buffer_ptr = capabilities_area;
        char *cl_str, *cm_raw_str, *goto_str_10_5;
        int lines = 24; // قيمة افتراضية لعدد الأسطر
        int cols = 80;  // قيمة افتراضية لعدد الأعمدة

        if (!isatty(STDOUT_FILENO)) {
            fprintf(stderr, "stdout is not a TTY. Termcap operations might not be visible or meaningful.\n");
            // يمكنك اختيار الخروج هنا أو الاستمرار بحذر
        }

        if (!term_name) {
            fprintf(stderr, "TERM not set.\n");
            return 1;
        }

        // (اختياري ولكن جيد) تعيين سرعة الإخراج لـ termcap (مهم للحشو)
        // هذا الجزء أكثر تعقيداً إذا لم تكن تستخدم ncurses التي قد تهتم به.
        // struct termios current_termios;
        // if (isatty(STDOUT_FILENO) && tcgetattr(STDOUT_FILENO, &current_termios) == 0) {
        //    ospeed = cfgetospeed(&current_termios); // استخرج السرعة
        //    // قد تحتاج إلى تحويل قيمة speed_t إلى قيمة قصيرة مناسبة لـ ospeed
        //    // بناءً على ثوابت السرعة Bxxxx. هذا معقد.
        //    // ncurses غالباً ما تدير هذا بشكل أفضل داخلياً.
        // } else {
        //    ospeed = B9600; // قيمة افتراضية إذا فشل tcgetattr
        // }
        // char pad_char_cap = tgetstr("pc", &buffer_ptr); // احصل على padding char
        // if (pad_char_cap) PC = *pad_char_cap; else PC = 0;


        if (tgetent(term_buffer, term_name) != 1) {
            fprintf(stderr, "Could not load termcap entry for %s.\n", term_name);
            return 1;
        }

        // الحصول على عدد الأسطر والأعمدة (كقيم احتياطية)
        int li_val = tgetnum("li");
        if (li_val > 0) lines = li_val;
        int co_val = tgetnum("co");
        if (co_val > 0) cols = co_val;
        // من الأفضل استخدام ioctl(TIOCGWINSZ) إذا أمكن

        printf("Terminal: %s, Lines: %d, Columns: %d\n", term_name, lines, cols);
        printf("Press Enter to clear screen, move cursor, and print 'Hello'...\n");
        getchar(); // انتظر ضغطة Enter

        // 1. مسح الشاشة
        cl_str = tgetstr("cl", &buffer_ptr);
        if (cl_str) {
            tputs(cl_str, lines, my_putchar_wrapper); // affcnt = lines (عدد الأسطر المتأثرة)
            fflush(stdout); // تأكد من إرسال الإخراج فوراً
        } else {
            printf("Clear screen (cl) not available.\n");
        }

        // انتظر قليلاً لرؤية التأثير
        // sleep(1); // قد تحتاج إلى <unistd.h>

        // 2. تحريك المؤشر إلى (العمود 10، الصف 5)
        cm_raw_str = tgetstr("cm", &buffer_ptr);
        if (cm_raw_str) {
            goto_str_10_5 = tgoto(cm_raw_str, 10, 5); // (cap, col, row)
            if (goto_str_10_5 && strcmp(goto_str_10_5, "OOPS") != 0) {
                tputs(goto_str_10_5, 1, my_putchar_wrapper); // affcnt = 1 (يؤثر على سطر واحد)
                fflush(stdout);
            } else {
                printf("Failed to format cursor motion string or cm is invalid.\n");
            }
        } else {
            printf("Cursor motion (cm) not available.\n");
        }
        
        // 3. طباعة رسالة في الموقع الجديد
        tputs("Hello, Termcap World!", 1, my_putchar_wrapper);
        fflush(stdout);

        // 4. تحريك المؤشر إلى أسفل الشاشة (مثلاً، الصف lines-1, العمود 0) للعودة إلى المطالبة
        if (cm_raw_str) {
            char *goto_bottom = tgoto(cm_raw_str, 0, lines - 1);
            if (goto_bottom && strcmp(goto_bottom, "OOPS") != 0) {
                tputs(goto_bottom, 1, my_putchar_wrapper);
                // عادةً ما يتم إخراج سطر جديد هنا لضمان أن المطالبة تظهر على سطر جديد
                // my_putchar_wrapper('\n'); 
            }
        }
        // لإخراج سطر جديد إضافي لضمان أن المطالبة التالية في مكان جيد
        my_putchar_wrapper('\n');
        fflush(stdout);


        return 0;
    }
    ```
    **لتجربة المثال:**
    1.  **احفظ الكود** باسم `use_tputs.c`.
    2.  **ترجمه:** `gcc use_tputs.c -o use_tputs -lncurses` (أو `-ltermcap`)
    3.  **شغله:** `./use_tputs`
        بعد الضغط على Enter، يجب أن ترى الشاشة تُمسح، ثم تُطبع كلمة "Hello, Termcap World!" في مكان ما بالقرب من (العمود 10، الصف 5)، ثم يعود المؤشر إلى أسفل الشاشة.

*   **اعتبارات هامة (Important Considerations):**
    *   **`tgetent` أولاً.**
    *   **الحشو و `ospeed`:** إذا كنت لا تستخدم ncurses (التي تتعامل مع هذا بشكل أفضل)، فإن الحشو الدقيق يتطلب تعيين `ospeed` (وسرعة الإدخال `SPEED` إذا كانت قدرة الإدخال تستخدم حشواً، وهو نادر).
    *   **`putc_func`:** استخدام `putchar` (أو غلاف له) هو الأكثر شيوعاً للإخراج إلى `stdout`.
    *   **`affcnt`:** قدّره بشكل معقول. `1` هي قيمة آمنة للعديد من القدرات.
    *   **`fflush(stdout)`:** بعد `tputs`، خاصة إذا كانت `putc_func` تكتب إلى `stdout`، غالباً ما تحتاج إلى استدعاء `fflush(stdout)` لضمان إرسال الإخراج إلى الطرفية فوراً، لأن `stdout` عادةً ما يكون buffered سطرياً عند الاتصال بطرفية.
    *   **البديل في ncurses:** في ncurses، لديك دوال مثل `putp()` (التي تستدعي `tputs` مع `putchar`)، أو يمكنك استخدام دوال Curses الأعلى مستوى مثل `mvaddstr()`, `clear()`, إلخ، التي تتعامل مع كل هذه التفاصيل نيابة عنك.

---

**خاتمة لمكتبة Termcap:**
لقد استكشفنا الآن الدوال الأساسية لواجهة Termcap:
*   `tgetent()`: لتحميل مدخل الطرفية.
*   `tgetflag()`, `tgetnum()`, `tgetstr()`: للحصول على القدرات المنطقية والرقمية والنصية.
*   `tgoto()`: لتنسيق سلاسل تحريك المؤشر (وغيرها من السلاسل ذات المعلمات).
*   `tputs()`: لإخراج السلاسل إلى الطرفية، مع معالجة الحشو.

هذه الأدوات، على الرغم من قدمها النسبي، لا تزال تشكل أساساً لفهم كيفية تحقيق البرامج التفاعلية (مثل المحررات، الألعاب النصية) لاستقلالية الطرفية. مكتبة ncurses الحديثة بُنيت على هذه المفاهيم ووسعتها بشكل كبير، موفرة واجهة Terminfo أكثر قوة بالإضافة إلى طبقة توافق لـ Termcap.

---

**ملخص شامل واستنتاجات:**

لقد قمنا برحلة مفصلة عبر مجموعة متنوعة من الدوال الحيوية للتفاعل مع الطرفيات في بيئات يونكس. دعنا نلخص ما تعلمناه:

1.  **فهم البيئة الطرفية:**
    *   `isatty(fd)`: يخبرك ما إذا كان واصف الملف `fd` متصلاً بطرفية. أساسي للتمييز بين التشغيل التفاعلي وغير التفاعلي.
    *   `ttyname(fd)` / `ttyname_r(fd, buf, len)`: يعطي اسم ملف الطرفية المرتبط بـ `fd`.
    *   `ttyslot()`: (مهمل) يحاول العثور على مدخل الطرفية في ملفات محاسبة المستخدمين القديمة.

2.  **التحكم العام والسمات:**
    *   `ioctl(fd, request, ...)`: دالة قوية ومنخفضة المستوى للتحكم في الأجهزة. طلبات مثل `TIOCGWINSZ` (للحصول على حجم النافذة) شائعة للطرفيات.
    *   `getenv(name)`: للحصول على متغيرات البيئة، وأهمها `TERM` الذي يحدد نوع الطرفية لمكتبات مثل Termcap/Terminfo.
    *   `tcgetattr(fd, termios_p)`: للحصول على السمات التفصيلية للطرفية (معدل الباود، الوضع القانوني/الخام، الصدى، أحرف التحكم، إلخ) في هيكل `struct termios`.
    *   `tcsetattr(fd, actions, termios_p)`: لتعيين سمات الطرفية. حاسم لتغيير سلوك الطرفية (مثل إيقاف الصدى، تمكين الوضع الخام).

3.  **استقلالية الطرفية (Termcap/Terminfo):**
    تهدف هذه المجموعة من الدوال إلى السماح للبرامج بالتفاعل مع أنواع مختلفة من الطرفيات دون الحاجة إلى ترميز تسلسلات التحكم الخاصة بكل طرفية بشكل ثابت.
    *   `tgetent(bp, name)`: تحميل وصف الطرفية `name` (من `getenv("TERM")`) من قاعدة بيانات Termcap/Terminfo.
    *   `tgetflag(id)`: التحقق من وجود قدرة منطقية (boolean).
    *   `tgetnum(id)`: الحصول على قيمة قدرة رقمية (مثل عدد الأعمدة/الأسطر).
    *   `tgetstr(id, area)`: الحصول على سلسلة قدرة نصية (مثل تسلسل مسح الشاشة، تحريك المؤشر).
    *   `tgoto(cap, col, row)`: تنسيق سلسلة قدرة (عادةً `cm`) بمعلمات (مثل العمود والصف).
    *   `tputs(str, affcnt, putc_func)`: إخراج سلسلة قدرة إلى الطرفية، مع معالجة الحشو اللازم.

**الأهمية والتطبيق العملي:**
هذه الدوال هي اللبنات الأساسية للعديد من البرامج التي نستخدمها يومياً:
*   **محررات النصوص كاملة الشاشة:** مثل `vim`, `emacs`, `nano` تستخدم `tcgetattr`/`tcsetattr` للدخول في الوضع الخام، و Termcap/Terminfo (عبر ncurses) لتحريك المؤشر، مسح أجزاء من الشاشة، تغيير الألوان، إلخ.
*   **الصدفات (Shells):** مثل `bash`, `zsh` تستخدم `isatty` لتحديد ما إذا كانت ستطبع مطالبة، و `tcgetattr`/`tcsetattr` لتحرير الأوامر (line editing).
*   **برامج مثل `top`, `htop`:** تستخدم `ioctl(TIOCGWINSZ)` لمعرفة حجم الشاشة وتحديث عرضها ديناميكياً، و Termcap/Terminfo لتحديث الشاشة بكفاءة.
*   **برامج قراءة كلمات المرور:** مثل `login`, `su`, `ssh` تستخدم `tcgetattr`/`tcsetattr` لتعطيل صدى الأحرف.
*   **الألعاب النصية (Roguelikes, MUDs):** تعتمد بشكل كبير على هذه التقنيات لعرض الخرائط والشخصيات.

**نصائح للمطور:**
*   **الاستعادة دائماً:** عند استخدام `tcsetattr` لتغيير وضع الطرفية، تأكد دائماً من استعادة الإعدادات الأصلية عند خروج البرنامج (باستخدام `atexit()` ومعالجات الإشارات).
*   **الأمان والتحقق:** تحقق من القيم المُرجعة لجميع الدوال، واستخدم `errno` لتشخيص الأخطاء. كن حذراً عند التعامل مع المدخلات من متغيرات البيئة أو المستخدم.
*   **استخدام مكتبات أعلى مستوى:** بالنسبة للتطبيقات المعقدة التي تتطلب تحكماً كاملاً في الشاشة، فإن استخدام مكتبة مثل `ncurses` (التي تستخدم هذه الدوال الأساسية داخلياً) يوفر تجريداً أعلى وأسهل في الاستخدام، ويتعامل مع العديد من التفاصيل الدقيقة لـ Terminfo نيابة عنك. ومع ذلك، فإن فهم الدوال الأساسية التي درسناها اليوم يمنحك تقديراً أعمق لكيفية عمل هذه المكتبات.
*   **الوثائق (Man Pages):** وثائق النظام (`man 3 function_name`, `man 5 terminfo`) هي مصادرك الأساسية للمعلومات الدقيقة والتفاصيل الخاصة بنظامك.

آمل أن يكون هذا الشرح المفصل قد ألقى الضوء الكافي على هذه الدوال الهامة. عالم التفاعل مع الطرفيات عالم غني بالتفاصيل، وإتقانه يفتح الباب أمام بناء تطبيقات تفاعلية قوية ومرنة. بالتوفيق في رحلتك البرمجية!
